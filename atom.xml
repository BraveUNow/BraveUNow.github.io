<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BraveUNow&#39;s hut</title>
  
  
  <link href="http://www.braveunow-hyx.xyz/atom.xml" rel="self"/>
  
  <link href="http://www.braveunow-hyx.xyz/"/>
  <updated>2022-06-05T12:32:45.663Z</updated>
  <id>http://www.braveunow-hyx.xyz/</id>
  
  <author>
    <name>BraveUNow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Benders分解</title>
    <link href="http://www.braveunow-hyx.xyz/2022/06/05/Benders%E5%88%86%E8%A7%A3/"/>
    <id>http://www.braveunow-hyx.xyz/2022/06/05/Benders%E5%88%86%E8%A7%A3/</id>
    <published>2022-06-05T12:11:10.000Z</published>
    <updated>2022-06-05T12:32:45.663Z</updated>
    
    <content type="html"><![CDATA[<p>以前写的一个笔记，拿来填充一下博客内容。。</p><h2 id="算法推导">1.算法推导</h2><p>对于一个线性规划问题： <span class="math display">\[\begin{align*}\text{Minimize}\quad c^Tx+f^Ty\\\text{s.t. }\quad Ax+By=b\\x\ge0,y\in Y\subseteq \mathbb{R}^q\end{align*}\]</span> <span id="more"></span></p><p>当y有一个比较复杂的约束（如为整数），而x为的约束较为简单（线性约束）时，模型求解computational cost会难以忍受，如果令y固定，求解x，可以缩小问题的规模，因此考虑将原模型分解成2个较小的子模型，当固定y时，相当于求一个只有变量x的子模型，令q(y)为： <span class="math display">\[\begin{align*}q(y)=\quad\text{Minimize}\quad c^Tx\\\text{s.t.}\quad Ax=b-By\\x\ge0\end{align*}\]</span> 则原问题可以表示为： <span class="math display">\[\begin{align*}\text{Minimize}\quad f^Ty+q(y)\\\text{s.t. }\quad y\in Y\end{align*}\]</span> 考虑到y取不同的值，q(y)的可行域发生变化，可以将子模型q(y)转化成对偶形式： <span class="math display">\[\begin{align*}\text{Maximize}\quad \alpha^T (b-By)\\\text{s.t. }\quad A^T\alpha\le c\\\alpha\text{ is unrestricted}\end{align*}\]</span> 将该模型作为子问题(subproblem), 注意到不论y的值怎么发生变化，子问题的约束不变，也就是说子问题的可行域不随输入y的变化而变化，y的不同只会影响子问题的目标值。子问题的可行域是一个<strong>多面体(polyhedron)</strong>，该多面体有<span class="math inline">\(I(\alpha_p^1,\alpha_p^2,\cdots,\alpha_p^I)\)</span>个<strong>极点(extreme points)</strong>,<span class="math inline">\(J(\alpha_r^1,\alpha_r^2,\cdots,\alpha_r^J)\)</span>个<strong>极方向(extreme rays)</strong>，对于多面体内任何一点都可以由极点和极方向的组合表示<span class="math inline">\(\forall \alpha=\{\sum\limits_i^I\lambda_i\alpha_p^i+\sum\limits_j^J\mu_j\alpha_r^j\mid\sum\limits_i^I\lambda_i=1,\lambda\ge0,\mu\ge0\}\)</span>。</p><ul><li><p>若可行域非空且无界，最优解一定可以由可行域的某个极方向表示。</p></li><li><p>若可行域非空且有界，最优解一定在可行域的某个极点上。</p></li><li><p>若可行域为空集，其对偶问题无界，则原问题也无界，模型目标值可以取到无穷小，失去求解意义。</p></li></ul><p>因此，原问题可以转化成： <span class="math display">\[\begin{align*}\text{Minimize}\quad f^Ty+max(\alpha^T (b-By))\\\text{s.t. }\quad A^T\alpha\le c\\y\in Y\end{align*}\]</span> 等价于: <span class="math display">\[\begin{align*}\text{(MP)=Minimize}\quad f^Ty+z\\\text{s.t. }\quad (\alpha_r^j)^T(b-By)\le0\quad j=1,2,\cdots,J\\(\alpha_p^i)^T(b-By)\le z\quad i =1,2,\cdots,I\\ \\ \\\text{(SP)=Maximize}\quad \alpha^T (b-By)\\\text{s.t. }\quad A^T\alpha\le c\\\alpha\text{ is unrestricted}\end{align*}\]</span> 将该模型作为主问题(master problem)，由于子问题的可行域可以有很多个极点和极方向，全部列举出来并不现实（也并不需要），因此我们可以先将主问题的约束全部松弛掉，形成限制主问题(restrict master problem)，并在每次迭代过程中逐步添加约束，即在满足最优性的条件下追求原问题的可行性，当限制主问题的z值与子问题的目标值相等时，主问题的所有约束都得到了满足</p><ul><li><p>对于给定的y值，任意极点乘以(b-By)都小于子问题的目标值=z, <span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span></p></li><li><p>对于给定的y值，没有极方向与y代表的向量小于90°，即（<span class="math inline">\(\alpha_r^j)^T(b-By)\le0\)</span>)，若小于90°，子问题的目标值可以无限大（<span class="math inline">\(\mid\alpha_r^j\mid\)</span>可以取任意值),子问题无界，其对偶问题无可行解，原问题也无可行解</p></li></ul><p>首先，求解RMP，得到对应的<span class="math inline">\((y^*,z^*)\)</span>。对于给定<span class="math inline">\(y*\)</span>，若SP得到无界解，说明对于该无界解对应的可行解是一个极方向，且此时对于该极方向j，与向量(b-By)的夹角小于90°，<span class="math inline">\((\alpha_r^j)^T(b-By)\ge0\)</span>，因此将这个极方向添加进RMP（add Benders feasibility cuts:<span class="math inline">\(\alpha_r^T(b-By)\le 0\)</span>, <span class="math inline">\(\alpha_r\)</span> is the extreme ray corresponding to current solution)；若SP得到最优解，且最优解的目标值大于<span class="math inline">\(z^*\)</span>，则说明存在某个极点<span class="math inline">\(\alpha_p^i\)</span>,代入目标函数得到的值大于<span class="math inline">\(z^*\)</span>，则违背了MP的约束<span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span>,因此将这个极点添加进RMP（add Benders optimality cuts:<span class="math inline">\(\alpha_p^T(b-By)\le z\)</span>, <span class="math inline">\(\alpha_p\)</span> is the extreme point corresponding to current solution),这样求解RMP得到的(b-By)与该极点向量相乘一定小于求解得到的<span class="math inline">\(z^*\)</span>；当最优解的目标值等于<span class="math inline">\(z^*\)</span>时，说明对于所有极点，与向量(b-By)的内积都小于<span class="math inline">\(z^*\)</span>，符合MP的约束，也就是说RMP得到的最优解是MP的可行解，且是MP的最优解。（松弛问题的可行域大于原问题的可行域，其最优解的目标值是原问题的下界，如果松弛问题的最优解可行，一定是原问题的最优解），这样MP也就得到了最优的解。</p><p><img src="C:/Users/64310/Desktop/GLRP/exact algorithm/benders decomposition/feasible domain.png" alt="feasible domain" style="zoom:30%;"></p><p>设求解RMP得到y的最优解在多面体极点B上，求解SP，得到最优点在极点E上，目标值为z，则对于<span class="math inline">\(\alpha\)</span>可行域任意极点<span class="math inline">\(\alpha_p^i\)</span>，<span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span>，此时添加新的极点约束进入RMP，相当于缩小y的可行域，且缩小后的y可行域一定包含点B（因为B是符合所有极点的约束的），则<span class="math inline">\(y_{new}\)</span>的最优一定也在B，SP的最优一定还在F，对结果没有影响，可以不用添加该cut。</p><p><img src="C:/Users/64310/Desktop/GLRP/exact algorithm/benders decomposition/feasible domain1.png" alt="feasible domain1" style="zoom:30%;"></p><h2 id="伪代码">2.伪代码</h2><p><span class="math display">\[\begin{align*}&amp;\mbox{\textbf {Classic Benders Decomposition}}\\&amp;\rule{20.3cm}{0.05em}\\&amp;\mbox{Indentify the primal MP and SP}\\&amp;\mbox{repeat:}\\&amp;\quad \mbox{Solve MP, get z}\\&amp;\quad \mbox{change SP's objective funciton}\\&amp;\quad \mbox{Solve SP}\\&amp;\quad \mbox{if SP.STATUS=OPTIMAL:}\\&amp;\quad\quad \mbox{if SP.obj=z:}\\&amp;\quad\quad\quad \mbox{stop}\\&amp;\quad\quad \mbox{else:}\\&amp;\quad\quad\quad \mbox{add Benders optimality cuts:}\alpha_p^T(b-By)\le z\\&amp;\quad \mbox{else:}\\&amp;\quad\quad\quad \mbox{add Benders feasibility cuts:}\alpha_r^T(b-By)\le 0\\\end{align*}\]</span></p><h2 id="算法实例">3.算法实例</h2><p>本实例来自Wiley Encyclopedia of Operations Research and Management Science的一个章节，原PDF见<a href="http://hacivat.ie.boun.edu.tr/~taskin/pdf/taskin_benders.pdf">Benders Decompositon</a> 对MIP问题:. <span class="math display">\[\begin{align*}min\quad &amp;x_1+x_2+x_3+x_4+x_5+7y_1+7y_2+7y_3+7y_4+7y_5\\\text{s.t. }\quad &amp;x_1+x_4+x_5=8\\&amp;x_2+x_5=3\\&amp;x_3+x_4=5\\&amp;x_1\le 8y_1\\&amp;_2\le 3y_2\\&amp;x_3\le 5y_3\\&amp;x_4\le 5y_4\\&amp;x_5\le 3y_5\\&amp;x_1,x_2,x_3,x_4,x_5\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\end{align*}\]</span></p><p><strong>step1.</strong> 识别MP和SP, 记<span class="math inline">\(\overline{(b-By)}=(8,3,5,8y_1,3y_2,5y_3,5y_4,3y_5)\)</span>: <span class="math display">\[\begin{align*}\text{(RMP)=Minimize}\quad &amp;7y_1+7y_2+7y_3+7y_4+7y_5+z\\\text{s.t. }\quad &amp;z\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\\ \\ \\\text{(SP)=Maximize}\quad &amp;8\alpha_1+3\alpha_2+5\alpha_3+8y_1\alpha_4+3y_2\alpha_5+5y_3\alpha_6+5y_4\alpha_7+3y_5\alpha_8\\\text{s.t. }\quad &amp;\alpha_1+\alpha_4\le1\\&amp;\alpha_2+\alpha_5\le1\\&amp;\alpha_3+\alpha_6\le1\\&amp;\alpha_1+\alpha_3+\alpha_7\le1\\&amp;\alpha_1+\alpha_2+\alpha_8\le1\\&amp;\alpha_1,\alpha_2,\alpha_3\text{ is unrestricted, }\alpha_4,\alpha_5,\alpha_6,\alpha_7,\alpha_8\le0\end{align*}\]</span></p><p><strong>step2.</strong> 求解RMP, 得最优解为<span class="math inline">\(y^*=(0,0,0,0,0),z^*=0\)</span>, 将<span class="math inline">\(y^*\)</span>代入SP, 发现SP有无穷解, 且我们得到该解对应的极射线<span class="math inline">\((1,0,0,-1,0,0,-1,-1)\)</span>, 之后我们可以添加feasibility cut: <span class="math inline">\(8-8y_1-5y_4-3y_5\le0\)</span>,等价于<span class="math inline">\(8y_1+5y_4+3y_5\ge8\)</span></p><p><strong>step3.</strong> 更新RMP,得最优解为<span class="math inline">\(y^*=(1,0,0,0,0),z^*=0\)</span>, SP仍然无界, 对应的极射线为<span class="math inline">\((0,1,1,0,-1,-1,-1,-1)\)</span>, 继续添加feasibility cut: <span class="math inline">\(3y_2+5y_3+5y_4+3y_5\ge8\)</span></p><p><strong>step4.</strong> 更新RMP,得最优解为<span class="math inline">\(y^*=(0,0,0,1,1),z^*=0\)</span>, SP有最优解<span class="math inline">\(8&gt;z=0\)</span>, 对应的极点为<span class="math inline">\((1,0,0,0,0,0,0,0)\)</span>, 添加optimality cut: <span class="math inline">\(8\le z\)</span></p><p><strong>step5.</strong> 更新RMP, 得最优解为 <span class="math inline">\(y^*=(0,0,0,1,1),z^*=8\)</span>, 当前的<span class="math inline">\(y^*\)</span>与上一次迭代相同, 因此SP的最优值一定为8, 等于当前的<span class="math inline">\(z^*\)</span>, 算法结束. 得到SP的对偶变量, 即原问题x的取值. 且最后的RMP为: <span class="math display">\[\begin{align*}\text{(RMP)=Minimize}\quad &amp;7y_1+7y_2+7y_3+7y_4+7y_5+z\\\text{s.t. }\quad &amp;8y_1+5y_4+3y_5\ge8\\&amp;3y_2+5y_3+5y_4+3y_5\ge8\\&amp;z\ge8\\&amp;z\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\end{align*}\]</span> 最终结果为<span class="math inline">\(x=(0,0,0,5,3),y=(0,0,0,1,1)\)</span>, objective=22</p><p>附Gurobi代码如下： </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gurobipy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">mp = Model()</span><br><span class="line">sp = Model()</span><br><span class="line"></span><br><span class="line">yNum = <span class="built_in">list</span>(np.arange(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">alphaNum = <span class="built_in">list</span>(np.arange(<span class="number">1</span>,<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">y = mp.addVars(yNum,obj=<span class="number">7</span>,vtype=GRB.BINARY,name=<span class="string">'y'</span>)</span><br><span class="line">z = mp.addVar(obj=<span class="number">1</span>,vtype=GRB.CONTINUOUS,name=<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">alpha = sp.addVars(alphaNum,vtype=GRB.CONTINUOUS,name=<span class="string">'alpha'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alphaNum:</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">        alpha[i].lb = -GRB.INFINITY<span class="comment">#等于约束的对偶变量无约束</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        alpha[i].lb = -GRB.INFINITY<span class="comment">#最小化问题小于约束对偶变量小于0</span></span><br><span class="line">        alpha[i].ub = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">c1 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">4</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c2 = sp.addConstr(alpha[<span class="number">2</span>]+alpha[<span class="number">5</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c3 = sp.addConstr(alpha[<span class="number">3</span>]+alpha[<span class="number">6</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c4 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">3</span>]+alpha[<span class="number">7</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c5 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">2</span>]+alpha[<span class="number">8</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">sp.ModelSense = GRB.MAXIMIZE</span><br><span class="line"></span><br><span class="line">sp.setParam(GRB.Param.InfUnbdInfo,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    mp.optimize()</span><br><span class="line">    sp.setObjective(<span class="number">8</span>*alpha[<span class="number">1</span>]+<span class="number">3</span>*alpha[<span class="number">2</span>]+<span class="number">5</span>*alpha[<span class="number">3</span>]+<span class="number">8</span>*y[<span class="number">1</span>].x*alpha[<span class="number">4</span>]+ \</span><br><span class="line">                    <span class="number">3</span>*y[<span class="number">2</span>].x*alpha[<span class="number">5</span>]+<span class="number">5</span>*y[<span class="number">3</span>].x*alpha[<span class="number">6</span>]+<span class="number">5</span>*y[<span class="number">4</span>].x*alpha[<span class="number">7</span>]+<span class="number">3</span>*y[<span class="number">5</span>].x*alpha[<span class="number">8</span>])</span><br><span class="line">        <span class="comment">#得到(b-By),设定subproblem的目标函数</span></span><br><span class="line">    sp.optimize()</span><br><span class="line">    <span class="keyword">if</span> sp.status == GRB.OPTIMAL:</span><br><span class="line">        <span class="keyword">if</span> sp.objVal == z.x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mp.addConstr(<span class="number">8</span>*alpha[<span class="number">1</span>].x+<span class="number">3</span>*alpha[<span class="number">2</span>].x+<span class="number">5</span>*alpha[<span class="number">3</span>].x+<span class="number">8</span>*y[<span class="number">1</span>]*alpha[<span class="number">4</span>].x+ \</span><br><span class="line">                         <span class="number">3</span>*y[<span class="number">2</span>]*alpha[<span class="number">5</span>].x+<span class="number">5</span>*y[<span class="number">3</span>]*alpha[<span class="number">6</span>].x+<span class="number">5</span>*y[<span class="number">4</span>]*alpha[<span class="number">7</span>].x+<span class="number">3</span>*y[<span class="number">5</span>]*alpha[<span class="number">8</span>].x&lt;=z)</span><br><span class="line">                <span class="comment">#add optimality cut</span></span><br><span class="line">    <span class="keyword">elif</span> sp.status == GRB.UNBOUNDED:</span><br><span class="line">        ray = sp.UnbdRay<span class="comment">#obtain extreme ray</span></span><br><span class="line">        mp.addConstr(<span class="number">8</span>*ray[<span class="number">0</span>]+<span class="number">3</span>*ray[<span class="number">1</span>] + <span class="number">5</span>*ray[<span class="number">2</span>] + \</span><br><span class="line">                     <span class="number">8</span>*ray[<span class="number">3</span>]*y[<span class="number">1</span>] + <span class="number">3</span>*ray[<span class="number">4</span>]*y[<span class="number">2</span>] + <span class="number">5</span>*ray[<span class="number">5</span>]*y[<span class="number">3</span>] + \</span><br><span class="line">                     <span class="number">5</span>*ray[<span class="number">6</span>]*y[<span class="number">4</span>] + <span class="number">3</span>*ray[<span class="number">7</span>]*y[<span class="number">5</span>]&lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#add feasibility cut</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (SP_Dual.status)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出变量值</span></span><br><span class="line">x = sp.getAttr(GRB.Attr.Pi,sp.getConstrs())<span class="comment">#x为sp对偶变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x[%d]:%g'</span>%(i+<span class="number">1</span>,x[i]))</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> mp.getVars():</span><br><span class="line">    <span class="built_in">print</span>(v.varName,<span class="string">':'</span>,v.x)</span><br></pre></td></tr></tbody></table></figure><p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前写的一个笔记，拿来填充一下博客内容。。&lt;/p&gt;
&lt;h2 id=&quot;算法推导&quot;&gt;1.算法推导&lt;/h2&gt;
&lt;p&gt;对于一个线性规划问题： &lt;span class=&quot;math display&quot;&gt;\[
\begin{align*}
\text{Minimize}\quad 
c^Tx+f^Ty\\
\text{s.t. }\quad Ax+By=b\\
x\ge0,y\in Y\subseteq \mathbb{R}^q
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="运筹学" scheme="http://www.braveunow-hyx.xyz/categories/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
    
    <category term="线性规划, 求解算法" scheme="http://www.braveunow-hyx.xyz/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到BraveUNow的博客</title>
    <link href="http://www.braveunow-hyx.xyz/2022/06/05/introduction/"/>
    <id>http://www.braveunow-hyx.xyz/2022/06/05/introduction/</id>
    <published>2022-06-05T03:19:50.000Z</published>
    <updated>2022-06-06T08:19:39.507Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客是基于hexo框架的next主题制作的（<a href="https://github.com/theme-next/hexo-theme-next.git">项目地址</a>，欢迎各位去给大佬star），由于我对前端不是很熟悉，博客的大部分配置都是参考网上的教程，因此博客整体比较朴素。在博客里我主要分享一些有关运筹学或者算法编程的学习心得体会（和我以前踩过的坑<span class="github-emoji"><span>😾</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）和一些生活经历，目前博客刚刚搭建，内容还不是特别丰富，因为主要是自己写着玩没有明确的目的性，更新大概也随缘，大家见谅。（背景图片是wallpaper engine上的一个壁纸，头像是丹霞小姐姐<span class="github-emoji"><span>👀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个博客是基于hexo框架的next主题制作的（&lt;a href=&quot;https://github.com/theme-next/hexo-theme-next.git&quot;&gt;项目地址&lt;/a&gt;，欢迎各位去给大佬star），由于我对前端不是很熟悉，博客的大部分配置都是参考网上的教程，</summary>
      
    
    
    
    
    <category term="Introduction" scheme="http://www.braveunow-hyx.xyz/tags/Introduction/"/>
    
  </entry>
  
  <entry>
    <title>几何角度看线性规划</title>
    <link href="http://www.braveunow-hyx.xyz/2022/06/04/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <id>http://www.braveunow-hyx.xyz/2022/06/04/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</id>
    <published>2022-06-04T05:43:36.000Z</published>
    <updated>2022-06-05T03:44:28.212Z</updated>
    
    <content type="html"><![CDATA[<p>最近在阅读Dimitris Bertsimas和John N. Tsitsiklis写的Introduction to linear optimization，学习过程中发现很多基本概念及其推导在我之前学运筹学的时候都忽视了，我学习运筹学时用的教材是清华大学出版社的《运筹学》第四版，这本书虽然我觉得写得不错，但可能由于需要介绍的知识太多，很多基本概念或细节没有深入介绍，相信很多人学习这本书的感受跟我一样。因此，在学习过程中，我也希望将这些内容分享给大家。</p><p>文章的主题为从几何角度看线性规划，内容包括线性规划的一些术语（多面体、极点等）介绍和一些性质推导，阅读本章需要有一些线性代数基础（不需要很多）。由于内容有点多，可能需要分好几节来进行介绍(作者本人也在一边看一边学<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>)，作者自己也只是一个本科生，全靠个人兴趣进行分享(可能很久才更一次<span class="github-emoji"><span>👀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>)，如果有什么地方讲得不对也希望大家能纠正。本章内容基于Introduction to linear optimization第二章，图片使用GeoGebra进行绘制。</p><span id="more"></span><h2 id="多面体和凸集">多面体和凸集</h2><h3 id="多面体">多面体</h3><p>在介绍多面体(polyhedron)之前，需要先引入超平面(hyperplane)和半空间(halfspace)的概念。假设<span class="math inline">\(a\)</span>是<span class="math inline">\(R^n\)</span>内的一个向量,<span class="math inline">\(b\)</span>是一个标量，则：</p><ul><li><strong>超平面</strong>为空间中的一个集合<span class="math inline">\(\{x\in R^n\vert a'x=b\}\)</span></li><li><strong>半空间</strong>为空间中的一个集合<span class="math inline">\(\{x\in R^n\vert a'x\ge b\}\)</span></li></ul><p>上述的意思很简单，超平面就是一条将整个空间分为两个部分的边界，在二维空间中表现为一条直线如<span class="math inline">\(x+y=1\)</span>，而半空间就是对应超平面分割空间后其中一侧的空间。注意到这里的向量<span class="math inline">\(a\)</span>其实就是对应超平面的法向量（即与超平面正交）。在了解超平面和半空间的概念后，多面体可以表示为有限数量的半空间的交集。如下图就是由<span class="math inline">\(a_i'x\ge b_i, i=1,2,3,4,5\)</span>，五个半空间的交集形成的多面体。</p><p><img src="C:/Users/64310/Pictures/线性规划/polyhedra.png" style="zoom:30%;"></p><p>因此，多面体可以表示成集合<span class="math inline">\(\{x\in R^n\vert Ax\ge B\}\)</span>，其中<span class="math inline">\(A\)</span>为<span class="math inline">\(m\times n\)</span>的矩阵，<span class="math inline">\(b\)</span>是一个<span class="math inline">\(m\times 1\)</span>的向量。特殊地，一个线性规划问题的标准形<span class="math inline">\(\{x\in R^n\vert Ax= B\}\)</span>也是一个多面体。一个多面体不一定是有界的(bounded)，如二维空间内由<span class="math inline">\((x_1\ge0,x_2\ge0)\)</span>形成的多面体就是无界的。</p><h3 id="凸集">凸集</h3><p>凸集(convex sets)的定义可以表示成：</p><ul><li>对于集合<span class="math inline">\(S\)</span>, 如果对于任何<span class="math inline">\(x,y\in S\)</span>和<span class="math inline">\(\lambda\in [0,1]\)</span>，都有<span class="math inline">\(\lambda x+(1-\lambda)y\in S\)</span>，则称集合<span class="math inline">\(S\subset R^n\)</span>是凸的(convex)。</li></ul><p><span class="math inline">\(\lambda x+(1-\lambda)y\)</span>的范围就是<span class="math inline">\(x,y\)</span>之间的一条线段，因此上述定义可以理解为，对于集合里面的任意两点之间的线段都在集合内部，则这个集合是凸集。下面引入两个概念：</p><p>设<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>为空间<span class="math inline">\(R^n\)</span>的向量，<span class="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_k\)</span>为非负标量且<span class="math inline">\(\sum_{i=1}^k\lambda_i=1\)</span></p><ul><li><p>向量<span class="math inline">\(\sum_{i=1}^k\)</span>被称为向量<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>的一个<strong>凸组合(convex combination)</strong></p></li><li><p>向量<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>的<strong>凸包(convex hull)</strong>是所有这些向量的凸组合.（如下图阴影部分即是向量<span class="math inline">\(x^1,\dots,x^7\)</span>的凸包）</p></li></ul><p><img src="C:/Users/64310/Pictures/线性规划/convex_hull.png" style="zoom:50%;"></p><p>基于上面的定义，下面将介绍一些关于凸性的定理。</p><ol type="1"><li><strong>凸集之间的交集也是凸的</strong></li></ol><p><strong>证明</strong>: 设有I个凸集<span class="math inline">\(S_i, i\in I\)</span>，并假设<span class="math inline">\(x,y\)</span>属于这些凸集的交集<span class="math inline">\(\cap_{i\in I}S_i\)</span>. 由于每个<span class="math inline">\(S_i\)</span>都是凸的且都包含向量<span class="math inline">\(x,y\)</span>，则有<span class="math inline">\(\lambda x+(1-\lambda)y\in S_i\)</span>，即<span class="math inline">\(x,y\)</span>的凸组合也在所有凸集<span class="math inline">\(S_i\)</span>的交集内。因此，<span class="math inline">\(\cap_{i\in I}S_i\)</span>是凸的。</p><ol start="2" type="1"><li><strong>每个多面体都是一个凸集</strong></li></ol><p><strong>证明</strong>: 令<span class="math inline">\(a\)</span>为一个向量, <span class="math inline">\(b\)</span>为标量，假设向量<span class="math inline">\(x,y\)</span>属于同一个半空间，即<span class="math inline">\(a'x\ge b\)</span>和<span class="math inline">\(a'y\ge b\)</span>。则对任意<span class="math inline">\(\lambda\in[0,1]\)</span>，<span class="math inline">\(a'(\lambda x+(1-\lambda )y)\ge\lambda b+(1-\lambda)b=b\)</span>，表明<span class="math inline">\(\lambda x+(1-\lambda )y\)</span>也在半空间内，因此半空间是一个凸集。而前文提到了多面体是有限个半空间的交集，根据定理1，可以得到多面体一定也是凸集。</p><ol start="3" type="1"><li><strong>一个凸集内部有限个元素的凸组合也属于这个凸集</strong></li></ol><p><strong>证明</strong>: 该定理的证明可以使用数学归纳法得到。根据凸集的定义可以知道对于凸集内部任意两个元素的凸组合也在凸集内部，假设k个元素的凸组合<span class="math inline">\(\sum_{i=1}^k\lambda_ix^i\)</span>也在凸集<span class="math inline">\(S\)</span>内部，如果能证明k+1个元素<span class="math inline">\(x^1,\dots,x^{k+1}\)</span>的凸组合<span class="math inline">\(\sum_{i=1}^{k+1}\lambda_ix^i\)</span>也在凸集<span class="math inline">\(S\)</span>内部，则定理成立。这里假设<span class="math inline">\(\lambda_{k+1}\ne1\)</span>，如果等式成立则显然该凸组合就位于<span class="math inline">\(x^{k+1}\)</span>处。 <span class="math display">\[\sum_{i=1}^{k+1}\lambda_ix^i=\lambda_{k+1}x^{k+1}+(1-\lambda_{x+1})\sum_{i=1}^{k}\frac{\lambda_i}{1-\lambda_{k+1}}x^i\]</span></p><p>右侧第二项的系数<span class="math inline">\(\lambda_i/(1-\lambda_{k+1})\)</span>是非负的且和为1，即右侧括号后的部分为前k个元素的凸组合，根据假设位于凸集<span class="math inline">\(S\)</span>内部，则k+1个元素的凸组合可以转化为<span class="math inline">\(x^{k+1}\)</span>和<span class="math inline">\(\sum_{i=1}^{k}\frac{\lambda_i}{1-\lambda_{k+1}}x^i\)</span>两个元素的凸组合，根据凸集的定义，最后可以得到<span class="math inline">\(\sum_{i=1}^{k+1}\lambda_ix^i\in S\)</span>，证明完毕。</p><ol start="4" type="1"><li><strong>有限个向量的凸包也是一个凸集</strong></li></ol><p><strong>证明</strong>: 设S是向量<span class="math inline">\(x^1,\dots,x^k\)</span>的凸包，令<span class="math inline">\(y=\sum_{i=1}^k\varsigma_ix^i, z=\sum_{i=1}^k\theta_ix^i,\sum_{i=1}^k\varsigma_i=1,\sum_{i=1}^k\theta_i=1\)</span>，根据凸包定义, <span class="math inline">\(y,z\)</span>都属于<span class="math inline">\(S\)</span>，则 <span class="math display">\[\lambda y+(1-\lambda)z=\lambda\sum_{i=1}^k\varsigma_ix^i+(1-\lambda)\sum_{i=1}^k\theta_ix^i=\sum_{i=1}^k(\lambda\varsigma_i+(1-\lambda)\theta_i)x_i\]</span> 显然<span class="math inline">\(\lambda\varsigma_i+(1-\lambda)\theta_i\)</span>都是非负的且和为1，因此，<span class="math inline">\(\lambda y+(1-\lambda)z\)</span>是<span class="math inline">\(x_i\)</span>的一个凸组合，根据凸包定义一定属于<span class="math inline">\(S\)</span>。因此，可以证明凸包的凸性。</p><h2 id="极点顶点和基可行解">极点、顶点和基可行解</h2><p>大家学习单纯形法的过程中应该都了解过一个线性规划的最优解一定出现在可行域的顶点处。但什么是可行域的顶点，Bertsimas的书中给出了3中不同的定义方式，本节将一一介绍。</p><h3 id="极点extreme-point">极点(extreme point)</h3><p>多面体的极点即为无法用多面体任何其他两个元素的凸组合表示的点。它的定义如下：</p><ul><li>令<span class="math inline">\(P\)</span>为一个多面体, 向量<span class="math inline">\(x\in P\)</span>是一个极点，如果我们找不到两个向量<span class="math inline">\(y,z\in P\)</span>和标量<span class="math inline">\(\lambda\)</span>，可以使<span class="math inline">\(x=\lambda y+(1-\lambda)z\)</span></li></ul><p>用通俗的话来讲，就是如果对于多面体上的一个点不在多面体内其他任何两个点连接而成的线段上，则这个点就是多面体的一个极点。</p><p><img src="C:/Users/64310/Pictures/线性规划/extreme_point.png" style="zoom:50%;"></p><p>上图中的x是一个极点，因为<span class="math inline">\(y\notin P\)</span>，而w不是一个极点，因为它可以表示为<span class="math inline">\(v,u\)</span>的凸组合，且<span class="math inline">\(v\in P, u\in P\)</span></p><h3 id="顶点vertex">顶点（vertex)</h3><p>多面体的的顶点可以定义为关于可行域P的一些线性规划问题的唯一最优解。它的定义如下：</p><ul><li>令<span class="math inline">\(P\)</span>为一个多面体，向量<span class="math inline">\(x\in P\)</span>是P的一个顶点如果存在一些<span class="math inline">\(c\)</span>可以使<span class="math inline">\(c'x\lt c'y\)</span>，其中<span class="math inline">\(y\in P, y\ne x\)</span></li></ul><p>上述定义通俗理解就是对于点<span class="math inline">\(x\)</span>，如果存在一条经过它的一条超平面可以令<span class="math inline">\(P\)</span>中所有点都在超平面的同一侧，且只有点<span class="math inline">\(x\)</span>在超平面上，则<span class="math inline">\(x\)</span>就是多面体的一个顶点。</p><h3 id="基可行解basic-feasible-solution">基可行解(basic feasible solution)</h3><p>根据多面体的定义，一个多面体<span class="math inline">\(P\subset R^n\)</span>可以用一系列线性等式和不等式约束表示： <span class="math display">\[a_i'x\ge b_i\quad i\in M_1\\a_i'x\le b_i\quad i\in M_2\\a_i'x= b_i\quad i\in M_3\]</span> 每个<span class="math inline">\(a_i\)</span>是<span class="math inline">\(R^n\)</span>中的一个向量, <span class="math inline">\(b_i\)</span>是一个标量。如果对于向量<span class="math inline">\(x^*\)</span>，存在某些<span class="math inline">\(i\in M_1,M_2,M_3\)</span>满足<span class="math inline">\(a_i'x^*=b_i,\)</span>，则称对应的约束<span class="math inline">\(i\)</span>为在<span class="math inline">\(x^*\)</span>上的有效约束(active/binding constraints)，否则称为无效约束，显然<span class="math inline">\(M_3\)</span>中的约束都是有效约束。根据线性代数的基础知识，如果一个线性规划问题由n个有效约束，且这n个约束是线性无关(linearly independent)的，则这个问题只有唯一解。</p><p>令<span class="math inline">\(x^*\)</span>为<span class="math inline">\(R^n\)</span>中的一个点，<span class="math inline">\(I=\{i\vert a_i'x^*=b_i\}\)</span>是在<span class="math inline">\(x^*\)</span>上的有效约束的索引，则下面三种表达是等价的：</p><ol type="1"><li><p>集合<span class="math inline">\(\{a_i\vert i\in I\}\)</span>内存在n个线性无关的向量</p></li><li><p>向量<span class="math inline">\(a_i,i\in I\)</span>张成的向量空间(span)是<span class="math inline">\(R^n\)</span>，即<span class="math inline">\(R^n\)</span>内任意元素都可以表示为<span class="math inline">\(a_i\)</span>的线性组合</p></li><li><p>线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有唯一解</p></li></ol><p><strong>证明：</strong></p><p><strong>表达1和表达2</strong>：如果向量<span class="math inline">\(a_i,i\in I\)</span>的span是<span class="math inline">\(R^n\)</span>，则由线性代数的知识可得这些向量中有n个向量构成了<span class="math inline">\(R^n\)</span>的一个基，这n个向量一定是线性无关的。同样，如果集合<span class="math inline">\(\{a_i\vert i\in I\}\)</span>内存在n个线性无关的向量，则这n个向量作为基张成的向量空间一定等于<span class="math inline">\(R^n\)</span>，即<span class="math inline">\(R^n\)</span>中的任何元素都可以表示为这n个向量的线性组合。</p><p><strong>表达2和表达3</strong>：如果线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有多个解，如<span class="math inline">\(x^1,x^2\)</span>，令非零向量<span class="math inline">\(d=x^1-x^2\)</span>, 则<span class="math inline">\(a_i'd=a_i'(x^1-x^2)=0\)</span>，即<span class="math inline">\(d\)</span>与所有<span class="math inline">\(a_i\)</span>正交，因此无法用<span class="math inline">\(a_i\)</span>的线性组合表示，从而不在span(<span class="math inline">\(a_i,i\in I\)</span>)内，说明span(<span class="math inline">\(a_i,i\in I\)</span>)不包括整个<span class="math inline">\(R^n\)</span>(至少不包括<span class="math inline">\(d\)</span>)。同样，如果span(<span class="math inline">\(a_i,i\in I\)</span>)的不等于<span class="math inline">\(R^n\)</span>，存在一个非零向量<span class="math inline">\(d\)</span>与span(<span class="math inline">\(a_i,i\in I\)</span>)正交，如果存在<span class="math inline">\(x\)</span>满足<span class="math inline">\(a_i'x=b_i,i\in I\)</span>，则<span class="math inline">\(a_i'(x+d)=b_i,i\in I\)</span>也一定满足，因此该线性方程组有多个解。</p><p>因此，如果对于一个有n个变量的线性规划问题，如果我们能找到n个有效约束则能唯一确定一个解。因此，这里引出了基解(basic solution)和基可行解的概念(basic feasible solution)。对于一个由一系列等式约束和不等式约束定义的多面体<span class="math inline">\(P\)</span>, 令<span class="math inline">\(x^*\)</span>为<span class="math inline">\(R^n\)</span>中的一个向量。</p><ul><li>所有在<span class="math inline">\(x^*\)</span>的有效约束中有<span class="math inline">\(n\)</span>个约束是线性无关的，则求解线性方程组得到的<span class="math inline">\(x^*\)</span>是一个<strong>基解</strong>.</li><li>如果<span class="math inline">\(x^*\)</span>是一个基解，且满足所有的约束，则是一个基可行解。</li></ul><p>对于一个线性规划问题，假设有n个变量，m个约束，其中有k个线性无关的等式约束，我们可以中所有不等式约束中寻找(n-k)个约束令其满足等式约束，这样就可以得到n个有效约束。</p><p><img src="C:/Users/64310/Pictures/线性规划/basic_solution.png" style="zoom:15%;"></p><p>假设线性规划问题的约束包括<span class="math inline">\(c_1:x+y\le 2;c_2:x-y\ge-1;c_3:x\ge0;c_4:y\ge0\)</span>，可行域如上图阴影部分区域所示，显然图中所有点都是都是基解，因为他们至少满足了两条线性无关的有效约束，如点E存在有效约束<span class="math inline">\(c_2,c_4\)</span>。但只有C、D、E、F是基可行解。</p><h3 id="extreme-point-vertex-basic-feasible-solution">extreme point, vertex, basic feasible solution</h3><p>以上三种概念虽然表达方式不同，但其实是等价的，并可以互换使用。本节将进行等价性的证明。</p><p><strong>vertex<span class="math inline">\(\rightarrow\)</span>extreme point</strong>：设<span class="math inline">\(x^*\in P\)</span>是一个顶点，则存在向量<span class="math inline">\(c\)</span>满足<span class="math inline">\(c'x^*\lt c'y,y\in P,y\ne x^*\)</span>。设有<span class="math inline">\(y\in P,y\ne x^*,z\in P,z\ne x^*\)</span>，则<span class="math inline">\(c'y\gt c'x^*,c'z\gt c'x^*\)</span>，<span class="math inline">\(c'(\lambda y+(1-\lambda)z)\gt c'x^*\)</span>，所以<span class="math inline">\((\lambda y+(1-\lambda)z)\ne x^*\)</span>因此<span class="math inline">\(x^*\)</span>无法表示为P中任意两个元素的凸组合, 是一个极点。</p><p><strong>extreme point<span class="math inline">\(\rightarrow\)</span> basic feasible solution</strong>：只要证明如果<span class="math inline">\(x^*\in P\)</span>不是一个基可行解，那一定不是极点即可。不是基可行解有两种情况。令<span class="math inline">\(I=\{a_i\vert a_ix^*=b_i\}\)</span>表示有效约束的集合，如果不存在n个线性无关的约束，则span(<span class="math inline">\(a_i,i\in I\)</span>)是<span class="math inline">\(R^n\)</span>的一个子集，一定存在<span class="math inline">\(d\in R^n\)</span>正交于所有约束向量令<span class="math inline">\(a_id=0,i\in I\)</span>。令<span class="math inline">\(\epsilon\)</span>是 一个很小的正数，并令<span class="math inline">\(y=x^*+\epsilon d,z=x^*-\epsilon d\)</span>，则对于所有有效约束<span class="math inline">\(i\in I\)</span>有<span class="math inline">\(a_i'y=a_i'z=0\)</span>，而对于无效约束<span class="math inline">\(i\notin I\)</span>，由于<span class="math inline">\(a_i'x^*\gt b_i\)</span>，由于<span class="math inline">\(\epsilon\)</span>很小(<span class="math inline">\(\epsilon\vert a_i'd\vert\lt a_i'x^*-b_i\)</span>)，则<span class="math inline">\(a_i'y\gt b_i,a_i'z\gt b_i\)</span>，因此<span class="math inline">\(y,z\)</span>都满足所有约束，使<span class="math inline">\(y\in P, z\in P\)</span>，则<span class="math inline">\(x^*=(y+z)/2\)</span>，可以表示为两个向量的凸组合；另一种情况是存在n个线性无关的有效约束，但<span class="math inline">\(x^*\)</span>违背了部分无效约束，即<span class="math inline">\(x^*\)</span>为basic solution, 不是basic feasible solution，则<span class="math inline">\(x^*\notin P\)</span>，自然不是极点了。</p><p><strong>basic feasible solution<span class="math inline">\(\rightarrow\)</span> vertex</strong>：如上令<span class="math inline">\(x^*\)</span>为一个basic feasible solution，<span class="math inline">\(I=\{a_i\vert a_ix^*=b_i\}\)</span>表示有效约束的集合，令<span class="math inline">\(c=\sum_{i\in I}a_i\)</span>,则有: <span class="math display">\[c'x^*=\sum_{i\in I}a_i'x^*=\sum_{i\in I}b^i\]</span> 此外，对于任何<span class="math inline">\(x\in P\)</span>，都满足所有约束<span class="math inline">\(a_i'x\ge b_i\)</span>，则 <span class="math display">\[c'x=\sum_{i\in I}a_i'x\ge \sum_{i\in I}b_i\]</span> 将<span class="math inline">\(c'x\)</span>当作一个目标函数，则<span class="math inline">\(x^*\)</span>是这个问题的下界，由于<span class="math inline">\(x^*\)</span>是一个基可行解，因此在<span class="math inline">\(x^*\)</span>处存在n个线性无关的有效约束，根据前面的证明这是与由这n个有效约束组成的线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有唯一解是等价的，因此<span class="math inline">\(c'x\)</span>只有在 <span class="math inline">\(x^*\)</span>才能使等式成立，对于所有<span class="math inline">\(x\in P,x\ne x^*\)</span>，都有<span class="math inline">\(c'x\gt c'x^*\)</span>，因此<span class="math inline">\(x^*\)</span>是一个vertex。</p><p>因此，如果一个向量是多面体的extreme point, 那它一定也是多面体的vertex或线性规划问题的一个basic feasible solution.</p><p>如果给定有限数量的线性不等式约束，则只有有限个数量的basic solution或basic feasible solution，也就是说一个多面体的extreme point或vertex的数量是有限的（但这个数字可能会很大）。</p><p><strong>证明</strong>：假设线性规划问题有m个不等式约束，由于任何basic solution都可以由n个线性无关的约束组成的线性方程组唯一确定，因此只需要在m个约束中找到n个线性无关的约束令等式成立就能获得一个basic solution，则basic solution的数量实际上是受限于m个不等式约束中能找到的n个线性无关约束的数量。</p><p>本章的内容先写到这里（肝了大半天写不动了<span class="github-emoji"><span>😫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），写着写着发现自己好像基本就是在翻译书本<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（但有些部分还是加了点个人理解，虽然不一定正确，作为本科生懂得真的不多），如果大家对此感兴趣还是欢迎大家去阅读原书。由于最近有好多事要做，之后的更新就随缘了。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在阅读Dimitris Bertsimas和John N. Tsitsiklis写的Introduction to linear optimization，学习过程中发现很多基本概念及其推导在我之前学运筹学的时候都忽视了，我学习运筹学时用的教材是清华大学出版社的《运筹学》第四版，这本书虽然我觉得写得不错，但可能由于需要介绍的知识太多，很多基本概念或细节没有深入介绍，相信很多人学习这本书的感受跟我一样。因此，在学习过程中，我也希望将这些内容分享给大家。&lt;/p&gt;
&lt;p&gt;文章的主题为从几何角度看线性规划，内容包括线性规划的一些术语（多面体、极点等）介绍和一些性质推导，阅读本章需要有一些线性代数基础（不需要很多）。由于内容有点多，可能需要分好几节来进行介绍(作者本人也在一边看一边学&lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;😂&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;)，作者自己也只是一个本科生，全靠个人兴趣进行分享(可能很久才更一次&lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;👀&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;)，如果有什么地方讲得不对也希望大家能纠正。本章内容基于Introduction to linear optimization第二章，图片使用GeoGebra进行绘制。&lt;/p&gt;</summary>
    
    
    
    <category term="运筹学" scheme="http://www.braveunow-hyx.xyz/categories/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
    
    <category term="线性规划" scheme="http://www.braveunow-hyx.xyz/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
