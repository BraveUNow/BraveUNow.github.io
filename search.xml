<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>几何角度看线性规划(二)</title>
      <link href="/2022/06/26/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E4%BA%8C/"/>
      <url>/2022/06/26/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="标准型的多面体">标准型的多面体</h2><p>​ 一个标准型的多面体可以表示为<span class="math inline">\(P=\{x\in R^n\vert Ax=b,x\ge0\}\)</span>，其中<strong>A</strong>是一个<span class="math inline">\(m\times n\)</span>的矩阵，对应m个等式约束和n个变量，并假设m个约束是相互独立(这要求<span class="math inline">\(m\le n\)</span>，事实上线性相关的约束可以被舍弃而不影响解的性质)</p><p>​ 上一章提到，一个基解是通过求解n个线性无关约束组成的线性方程组得到的，由于标准型的约束数量m不多于n，为了获得一个基解，需要选择m-n个变量并令它们为0，即令这m-n个变量对应的约束<span class="math inline">\(x_i\ge0\)</span>成为有效约束。其中对于这m-n个约束的选择并不是随意的。</p><p><strong>定理</strong>：对于一个标准型的多面体，向量<span class="math inline">\(x\in R^n\)</span>是一个基解当且仅当有<span class="math inline">\(Ax=b\)</span>，且存在索引<span class="math inline">\(B(1),\dots,B(m)\)</span>令：</p><ol type="1"><li>列<span class="math inline">\(A_{B(1)},\dots, A_{B(m)}\)</span>相互线性独立</li><li>如果<span class="math inline">\(i\neq B(1),\dots,B(m)\)</span>，则<span class="math inline">\(x_i=0\)</span></li></ol><p><strong>证明</strong>：假设<span class="math inline">\(x\in R^n\)</span>，且存在<span class="math inline">\(B(1),\dots,B(m)\)</span>满足定理的表述，则有 <span class="math display">\[\sum_{i=1}^{m}A_{B(i)}x_{B(i)}=\sum_{i=1}^nA_ix_i=Ax=b\]</span> ​ 由于列<span class="math inline">\(A_{B(1)},\dots, A_{B(m)}\)</span>相互线性独立，因此<span class="math inline">\(x_{B(1)},\dots,x_{B(m)}\)</span>的值是唯一的，即由n个有效约束形成的线性方程组有唯一解(其余n-m个变量值都为0)，说明<span class="math inline">\(x\)</span>是一个基解。</p><p>​ 相反，若<span class="math inline">\(x\)</span>是一个基解。令<span class="math inline">\(x_{B(1)},\dots,x_{B(k)}\)</span>表示<span class="math inline">\(x\)</span>中非0的索引。由于<span class="math inline">\(x\)</span>是基解，因此线性方程组<span class="math inline">\(\sum_{i=1}^nA_ix_i=b\)</span>和<span class="math inline">\(x_i=0,i\neq B(1),\dots,B(k)\)</span>有唯一解，即<span class="math inline">\(x_{B(1)},\dots,x_{B(k)}\)</span>是线性方程组组<span class="math inline">\(\sum_{i=1}^kA_ix_i=b_i\)</span>的唯一解，进而得到<span class="math inline">\(A_{B(1)},\dots A_{B(k)}\)</span>是线性独立的。因为若不是相互线性独立，则存在不全为零的标量<span class="math inline">\(\lambda_1,\dots,\lambda_k\)</span>满足<span class="math inline">\(\sum_{i=1}^kA_i\lambda_i=0\)</span>，进而<span class="math inline">\(\sum_{i=1}^kA_i(x_i+\lambda_i)=b_i\)</span>，与前面解的唯一性相矛盾。</p><span id="more"></span><p>​ 由于<span class="math inline">\(A_{B(1)},\dots A_{B(k)}\)</span>线性独立，则可以得出<span class="math inline">\(k\le m\)</span>(矩阵最大的秩为m)。由于m有个线性独立的行，也一定能找到m个线性独立的列。因此，我们能找到m-k个额外的列<span class="math inline">\(A_{k+1},\dots,A(m)\)</span>使得列<span class="math inline">\(A_{B(1)},\dots,A_{B(m)}\)</span>线性独立。则如果<span class="math inline">\(i\neq B(1),\dots,B(m)\)</span>，有<span class="math inline">\(i\neq B(1),\dots,B(k)\)</span>，得到<span class="math inline">\(x_i=0\)</span>。因此，定理的两个表述都得到满足。</p><p>​ 根据以上理论，任何一个基解都可以用以下的步骤确定：</p><ol type="1"><li>选择m个线性独立的列<span class="math inline">\(A_{B(1)},\dots A_{B(m)}\)</span></li><li>对所有<span class="math inline">\(i\neq B(1),\dots,B(m)\)</span>,令<span class="math inline">\(x_i=0\)</span></li><li>解线性方程组<span class="math inline">\(Ax=b\)</span>，<span class="math inline">\([x_{B(1)},\dots,x_{B(m)}]^T\)</span></li></ol><p>​ 通过以上步骤，如果得到的基解都是非负的，则该基解是一个基可行解。对于一个基解，变量<span class="math inline">\(x_{B(1)},\dots,x_{B(m)}\)</span>被称为基变量(basic variables)，其余变量被称为非基变量(nonbasic)，而基向量对应的列<span class="math inline">\(A_{B(1)},\dots A_{B(m)}\)</span>被称为基列向量(basic columns)，这m个向量构成了空间<span class="math inline">\(R^m\)</span>的一个基。一般认为如果两个基有不同的索引<span class="math inline">\(\{B(1),\dots,B(m\}\)</span>，则称这两个基是不同的(索引相同顺序不同也视为同一个基)</p><p>​ 在确定一个基后，该基的值可以通过求解线性方程组<span class="math inline">\(Bx_B=b\)</span>来确定，其中<span class="math inline">\(B\)</span>是由所有基变量对应的列向量组成的<span class="math inline">\(A\)</span>的一个分块矩阵，由于<span class="math inline">\(B\)</span>的列向量都是线性独立的，因此<span class="math inline">\(B\)</span>一定可逆，<span class="math inline">\(x_B\)</span>可以通过计算<span class="math inline">\(B^{-1}b\)</span>唯一确定。</p><p>​ 从另一个角度看，<span class="math inline">\(Ax=b\)</span>或<span class="math inline">\(\sum_{i=1}^nA_ix_i=b\)</span>可以看做为列向量<span class="math inline">\(A_i\)</span>通过对应的系数<span class="math inline">\(x_i\)</span>相加而合成向量<span class="math inline">\(b\)</span>。假设考虑一个m=2, n=4的标准型，4个变量列向量分别对应下图中的<span class="math inline">\(A_1,A_2,A_3,A_4\)</span>，当令<span class="math inline">\(A_1,A_2\)</span>形成一个基时，得到的基解是不可行的，因为<span class="math inline">\(x_2\)</span>一定要小于0才能将<span class="math inline">\(A_1,A_2\)</span>合成到<span class="math inline">\(b\)</span>。同理<span class="math inline">\(A_1,A_3\)</span>为基得到的基解是可行的，而<span class="math inline">\(A_1,A_4\)</span>无法形成一个基，因为这两个向量是线性相关的。</p><p><img src="C:/Users/64310/Pictures/线性规划/synthesizeVector.png" style="zoom:30%;"></p><h3 id="基和基解的对应关系">基和基解的对应关系</h3><p>前文提到两个基解是相邻的当它们有相同的n-1个有效约束，在标准形式下，我们称两个基是相邻的当它们有n-1个相同的基列向量索引，因此相邻的基解可以通过相邻的基获得。</p><p><strong>推论</strong>：令<span class="math inline">\(P=\{x\vert Ax=b,x\ge0\}\)</span>为一个非空的多面体，其中<span class="math inline">\(A\)</span>是一个<span class="math inline">\(m\times n\)</span>矩阵，其行索引为<span class="math inline">\(a_1',\dots,a_m'\)</span>，假设<span class="math inline">\(rank(A)=k\lt m\)</span>且行<span class="math inline">\(a_{i1}',\dots,a_{ik}'\)</span>是线性独立的，则多面体<span class="math inline">\(Q=\{x\vert a'_{i1}x=b_{i1},\dots,a_{ik}'x=b_{ik},x\ge0\}\)</span>，则<span class="math inline">\(Q=P\)</span></p><p><strong>证明</strong>：假设矩阵A的前k行是线性独立的，即<span class="math inline">\(i_1=1,\dots,i_k=k\)</span>。显然<span class="math inline">\(P\subset Q\)</span>,因为任何满足Q所有约束的解都满足P的所有约束。由于<span class="math inline">\(rank(A)=k\)</span>，则行向量<span class="math inline">\(a_{i1}',\dots,a_{ik}'\)</span>构成了行空间的一个基，因此A的任意一个行向量<span class="math inline">\(a_i'\)</span>都能表示为<span class="math inline">\(a_i'=\sum_{j=1}^k\lambda_{ija_j'}\)</span>.令<span class="math inline">\(x\)</span>表示P的一个约束，则 <span class="math display">\[b_i=a_i'x=\sum_{j=1}^k\lambda_{ij}a_j'x=\sum_{j=1}^k\lambda_{ij}b_j\]</span> 因此，对于Q中的任意一个元素y，都可以表示为： <span class="math display">\[a_i'y=\sum_{j=1}^k\lambda_{ij}a_j'y=\sum_{j=1}^k\lambda_{ij}b_j=b_i\]</span> 即<span class="math inline">\(y\in P\)</span>，因此得到<span class="math inline">\(Q\subset P\)</span>，进而推出<span class="math inline">\(Q=P\)</span></p><p>因此，在可行域非空的情况下，一个标准型的线性规划问题总能转为一个所有等式约束都相互独立的等价的标准型问题。</p><h3 id="退化解">退化解</h3><p><strong>定义</strong>：当在基解<span class="math inline">\(x\)</span>处有超过n个有效约束，则称<span class="math inline">\(x\in R^n\)</span>是退化解。</p><p>在二维空间，一个退化解是三个及以上直线的交点，三维空间是四个以上平面的交界。考虑多面体P： <span class="math display">\[\begin{align}x_1+x_2+2x_3&amp;\le8\\x_2+6x_3&amp;\le12\\x_1&amp;\le4\\x_2&amp;\le6\\x_1,x_2,x_3&amp;\ge0\\\end{align}\]</span> ​ 向量<span class="math inline">\(x=(2,6,0)\)</span>不是退化解，而向量<span class="math inline">\(x=(4,0,2)\)</span>是退化解，因为它同时满足4个有效约束，分别为<span class="math inline">\(x_1+x_2+2x_3\le8,x_2+6x_3\le12,x_1\le4,x_2\ge_0\)</span></p><p>​ 而对于一个标准型的多面体，其m个等式约束一定是有效的，因此拥有超过n个有效约束与拥有超过n-m个值为零的变量是等价的，即引出以下定义：</p><p><strong>定义</strong>：对于标准型<span class="math inline">\(P=\{x\in R^n\vert Ax=b,x\ge0\}\)</span>, <span class="math inline">\(x\)</span>是一个基解, m是<span class="math inline">\(A\)</span>的行数。当向量<span class="math inline">\(x\)</span>有超过n-m个为的元素，<span class="math inline">\(x\)</span>是一个退化的基解。</p><p>当基解<span class="math inline">\(x\)</span>是退化的时候，我们有超过一种方式从这些值为的变量中选择n-m个变量作为非基变量，在这种情况下，会出现几个不同的基对应同一个基解的情况。</p><p>一个基可行解的退化不完全是多面体的几何性质，它依赖于一个多面体的特定描述。考虑多面体： <span class="math display">\[P=\{(x_1.x_2,x_3)\vert x_1-x_2=0,x_1+x_2+2x_3=2,x_1,x_2,x_3\ge0\}\]</span> <img src="C:/Users/64310/Pictures/线性规划/degenerationSample.png" style="zoom:50%;"></p><p>该多面体n=3,m=2，则n-m=1.向量(1,1,0)是非退化解，因为只有一个变量值为0.而向量(0,0,1)是退化解，因为有2个变量值为0.但对该多面体换一种方式描述<span class="math inline">\(P=\{(x_1.x_2,x_3)\vert x_1-x_2=0,x_1+x_2+2x_3=2,x_1,x_3\ge0\}\)</span>,向量(0,0,1)就不再是一个退化基可行解了。</p><p>因此，一个基可行解在一种表述下是退化解，而在另一种表述下可能就不是退化解。</p><h2 id="极点extreme-point">极点(extreme point)</h2><h3 id="极点的存在性">极点的存在性</h3><p>本节说明极点存在的条件，首先引入下面的概念：</p><p><strong>定义</strong>：多面体<span class="math inline">\(P\subset R^n\)</span>含有一条直线，当存在向量<span class="math inline">\(x\in P\)</span>和非零向量<span class="math inline">\(d\in R^n\)</span>对于任意标量<span class="math inline">\(\lambda\)</span>满足<span class="math inline">\(x+\lambda d\in P\)</span></p><p>不是所有多面体都有极点的，如一个半空间就不存在顶点，下面将给出极点存在性的等价表示：</p><p><strong>定理</strong>：设多面体<span class="math inline">\(P=\{x\in R^n\vert a_i'x\ge b_i,i=1,\dots,m\}\)</span>非空，则一下表述是等价的：</p><ol type="1"><li>多面体P至少存在一个极点</li><li>多面体P不含有一条直线</li><li>在向量组<span class="math inline">\(a_1,\dots,a_m\)</span>中有n个相互线性独立的向量</li></ol><p><strong>证明</strong>：</p><p>(2)→(1)：首先证明如果P不含有一条直线，则一定存在一个极点。令<span class="math inline">\(x\)</span>为P中的一个元素，且<span class="math inline">\(I=\{i\vert a_i'x=b_i\}\)</span>。如果I中存在n个线性无关的向量，即有n个线性无关的独立约束，则<span class="math inline">\(x\)</span>显然是一个基可行解，根据之前的证明，基可行解和极点是等价的。若I中不存在n个线性无关的向量，则所有<span class="math inline">\(a_i,i\in I\)</span>构成了<span class="math inline">\(R^n\)</span>的一个子空间，则存在非零向量<span class="math inline">\(d\in R^n\)</span>与所有<span class="math inline">\(a_i,i\in I\)</span>正交使<span class="math inline">\(a_i'd=0,i\in I\)</span>。考虑向量<span class="math inline">\(y=x+\lambda d\)</span>，当<span class="math inline">\(i\in I\)</span>时，<span class="math inline">\(a_i'y=a_i'x+\lambda a_id=a_i'x=b_i\)</span>，即对于I中的约束仍为有效约束。但由于多面体不含有直线，因此当<span class="math inline">\(\lambda\)</span>大到某一个值<span class="math inline">\(\lambda^*\)</span>时一定会有一些约束<span class="math inline">\(j\notin I\)</span>将要被违背，这时候的向量y相比向量x多了一个有效约束，通过这样的方式不断添加有效约束，最终可以得到一个极点。</p><p>(1)→(3)：如果P是一个极点，则P也是一个基可行解，因此在<span class="math inline">\(x\)</span>处存在n个有效约束，其对于的向量<span class="math inline">\(a_i\)</span>也是相互线性独立的</p><p>(3)→(2)：不失一般性假设<span class="math inline">\(a_1,\dots,a_n\)</span>是相互线性独立的。若<span class="math inline">\(P\)</span>存在一条直线<span class="math inline">\(x+\lambda d\)</span>，<span class="math inline">\(d\in R^n,d&gt;0\)</span>则对所有的<span class="math inline">\(i,\lambda\)</span>有<span class="math inline">\(a_i'(x+\lambda d)\ge b_i\)</span>，因此<span class="math inline">\(a_i'd=0\)</span>，但由于<span class="math inline">\(a_i,\dots,a_n\)</span>是相互线性独立的能够构成<span class="math inline">\(R_n\)</span>的一个基，则d=0，与前面假设矛盾，因此多面体不存在一条直线。</p><p>一个有界的多面体不存在一条直线，比如一个正象限<span class="math inline">\(\{x\vert x\ge 0\}\)</span>不存在一条直线。由于一个标准型的多面体被正象限所包括，它一定也不存在一条直线，因此一个非空有界的多面体或一个标准型的多面体至少有一个基可行解。</p><h3 id="极点的最优性">极点的最优性</h3><p>在建立极点的存在性条件后，本节将证明如果一个线性规划问题有最优解且可行域存在至少一个极点，则最优解出现在极点上。</p><p><strong>定理</strong>：可行域为多面体P的线性规划问题以最小化成本<span class="math inline">\(c'x\)</span>为目标函数，设P有至少一个极点且问题有最优解，则存在一个最优解是P的一个极点。</p><p><strong>证明</strong>：令Q表示最优解的集合，v表示成本<span class="math inline">\(c'x\)</span>的最小值，则Q可以表示为<span class="math inline">\(Q=\{x\in R^n\vert Ax\ge b,c'x=v\}\)</span>，也是一个多面体。由于P存在极点，即P不存在一条直线，而<span class="math inline">\(Q\subset P\)</span>，也不存在一条直线，有至少一个极点。设<span class="math inline">\(x^*\)</span>为Q的一个极点，若<span class="math inline">\(x^*\)</span>不是P的极点，存在<span class="math inline">\(y\in P,z\in P\)</span>使得<span class="math inline">\(x=\lambda y+(1-\lambda)z,z\in[0,1]\)</span>, 则<span class="math inline">\(v=c'x=c'\lambda y+c'(1-\lambda)z\)</span>，由于v是原问题的最优解，<span class="math inline">\(c'y\ge v,c'z\ge z\)</span>，只有<span class="math inline">\(c'y=c'z=v\)</span>时等式成立，这表示<span class="math inline">\(y\in Q,z\in Q\)</span>，与<span class="math inline">\(x^*\)</span>是Q的一个极点相矛盾，因此<span class="math inline">\(x^*\)</span>是P的一个极点。</p><p>上述证明适用于标准型或有界的多面体，因为它们不包含直线。下面的证明将表示如果最优解不是无穷的，则一定存在最优解出现在极点上。</p><p><strong>定理</strong>：可行域为多面体P的线性规划问题以最小化成本<span class="math inline">\(c'x\)</span>为目标函数，设P至少有一个极点，则要么最优解的值为<span class="math inline">\(-\infty\)</span>，或存在一个极点为最优解。</p><p><strong>证明</strong>：在证明前使用以下术语：向量<span class="math inline">\(x\in P\)</span>的秩为k，当在<span class="math inline">\(x\)</span>处可以找到最多k个线性无关的有效约束。设最优解是有界的，考虑一些<span class="math inline">\(x\in P,rank(x)=k&lt;n\)</span>，令<span class="math inline">\(I=\{i\vert a_i'x=b_i\}\)</span>，由于k&lt;n，因此<span class="math inline">\(a_i,i\in I\)</span>张成了<span class="math inline">\(R^n\)</span>的一个子空间，存在向量<span class="math inline">\(d\ne 0\)</span>与所有<span class="math inline">\(a_i,i\in I\)</span>正交使<span class="math inline">\(a_id=0\)</span>，通过选择<span class="math inline">\(d\)</span>的值的正负性可以令<span class="math inline">\(c'd&lt;0\)</span>。考虑射线<span class="math inline">\(y=x+\lambda d\)</span>，由于d与x的有效约束向量正交，因此有<span class="math inline">\(a_iy=b_i,i\in I\)</span>。当整条射线都在P内部时，<span class="math inline">\(\vert d\vert\)</span>可以取无限大，则最小成本就为<span class="math inline">\(-\infty\)</span>。若只有部分在P内部，则在边界上有<span class="math inline">\(\lambda^*&gt;0,j\notin I\)</span>使得<span class="math inline">\(a_j'(x+\lambda^*d)=a_j'y=b_j\)</span>，由于<span class="math inline">\(c'd&lt;0\)</span>，因此<span class="math inline">\(c'y&lt;c'x\)</span>，且此时y的秩为k+1. 如果c与d也是正交的，则最后得到<span class="math inline">\(c'y=c'x\)</span>，</p><p>​ 通过这种方式总可以找到一个新的向量<span class="math inline">\(y\in P,c'y\le c'x,rank(y)&gt;rank(x)\)</span>，通过重复这种方式最终可以找到一个向量<span class="math inline">\(w\)</span>令<span class="math inline">\(c'w\le c'x\)</span>，且<span class="math inline">\(w\)</span>的秩为n。因此<span class="math inline">\(w\)</span>是一个基可行解，也是一个极点。令<span class="math inline">\(w^1,\dots,w^r\)</span>表示P中基可行解的集合，且<span class="math inline">\(w^*\)</span>是最优的基可行解<span class="math inline">\(c'w^*\le c'w^i\)</span>。前面已经证明了对于每一个<span class="math inline">\(x\)</span>都能找到一些<span class="math inline">\(i\)</span>令<span class="math inline">\(c'w^i\le c'x\)</span>，因此可以得到<span class="math inline">\(c'w^*\le c'x\)</span>，<span class="math inline">\(w^*\)</span>是最优的。</p>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Benders分解</title>
      <link href="/2022/06/05/Benders%E5%88%86%E8%A7%A3/"/>
      <url>/2022/06/05/Benders%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>以前写的一个笔记，拿来填充一下博客内容。。</p><h2 id="算法推导">1.算法推导</h2><p>对于一个线性规划问题： <span class="math display">\[\begin{align*}\text{Minimize}\quad c^Tx+f^Ty\\\text{s.t. }\quad Ax+By=b\\x\ge0,y\in Y\subseteq \mathbb{R}^q\end{align*}\]</span> <span id="more"></span></p><p>当y有一个比较复杂的约束（如为整数），而x为的约束较为简单（线性约束）时，模型求解computational cost会难以忍受，如果令y固定，求解x，可以缩小问题的规模，因此考虑将原模型分解成2个较小的子模型，当固定y时，相当于求一个只有变量x的子模型，令q(y)为： <span class="math display">\[\begin{align*}q(y)=\quad\text{Minimize}\quad c^Tx\\\text{s.t.}\quad Ax=b-By\\x\ge0\end{align*}\]</span> 则原问题可以表示为： <span class="math display">\[\begin{align*}\text{Minimize}\quad f^Ty+q(y)\\\text{s.t. }\quad y\in Y\end{align*}\]</span> 考虑到y取不同的值，q(y)的可行域发生变化，可以将子模型q(y)转化成对偶形式： <span class="math display">\[\begin{align*}\text{Maximize}\quad \alpha^T (b-By)\\\text{s.t. }\quad A^T\alpha\le c\\\alpha\text{ is unrestricted}\end{align*}\]</span> 将该模型作为子问题(subproblem), 注意到不论y的值怎么发生变化，子问题的约束不变，也就是说子问题的可行域不随输入y的变化而变化，y的不同只会影响子问题的目标值。子问题的可行域是一个<strong>多面体(polyhedron)</strong>，该多面体有<span class="math inline">\(I(\alpha_p^1,\alpha_p^2,\cdots,\alpha_p^I)\)</span>个<strong>极点(extreme points)</strong>,<span class="math inline">\(J(\alpha_r^1,\alpha_r^2,\cdots,\alpha_r^J)\)</span>个<strong>极方向(extreme rays)</strong>，对于多面体内任何一点都可以由极点和极方向的组合表示<span class="math inline">\(\forall \alpha=\{\sum\limits_i^I\lambda_i\alpha_p^i+\sum\limits_j^J\mu_j\alpha_r^j\mid\sum\limits_i^I\lambda_i=1,\lambda\ge0,\mu\ge0\}\)</span>。</p><ul><li><p>若可行域非空且无界，最优解一定可以由可行域的某个极方向表示。</p></li><li><p>若可行域非空且有界，最优解一定在可行域的某个极点上。</p></li><li><p>若可行域为空集，其对偶问题无界，则原问题也无界，模型目标值可以取到无穷小，失去求解意义。</p></li></ul><p>因此，原问题可以转化成： <span class="math display">\[\begin{align*}\text{Minimize}\quad f^Ty+max(\alpha^T (b-By))\\\text{s.t. }\quad A^T\alpha\le c\\y\in Y\end{align*}\]</span> 等价于: <span class="math display">\[\begin{align*}\text{(MP)=Minimize}\quad f^Ty+z\\\text{s.t. }\quad (\alpha_r^j)^T(b-By)\le0\quad j=1,2,\cdots,J\\(\alpha_p^i)^T(b-By)\le z\quad i =1,2,\cdots,I\\ \\ \\\text{(SP)=Maximize}\quad \alpha^T (b-By)\\\text{s.t. }\quad A^T\alpha\le c\\\alpha\text{ is unrestricted}\end{align*}\]</span> 将该模型作为主问题(master problem)，由于子问题的可行域可以有很多个极点和极方向，全部列举出来并不现实（也并不需要），因此我们可以先将主问题的约束全部松弛掉，形成限制主问题(restrict master problem)，并在每次迭代过程中逐步添加约束，即在满足最优性的条件下追求原问题的可行性，当限制主问题的z值与子问题的目标值相等时，主问题的所有约束都得到了满足</p><ul><li><p>对于给定的y值，任意极点乘以(b-By)都小于子问题的目标值=z, <span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span></p></li><li><p>对于给定的y值，没有极方向与y代表的向量小于90°，即（<span class="math inline">\(\alpha_r^j)^T(b-By)\le0\)</span>)，若小于90°，子问题的目标值可以无限大（<span class="math inline">\(\mid\alpha_r^j\mid\)</span>可以取任意值),子问题无界，其对偶问题无可行解，原问题也无可行解</p></li></ul><p>首先，求解RMP，得到对应的<span class="math inline">\((y^*,z^*)\)</span>。对于给定<span class="math inline">\(y*\)</span>，若SP得到无界解，说明对于该无界解对应的可行解是一个极方向，且此时对于该极方向j，与向量(b-By)的夹角小于90°，<span class="math inline">\((\alpha_r^j)^T(b-By)\ge0\)</span>，因此将这个极方向添加进RMP（add Benders feasibility cuts:<span class="math inline">\(\alpha_r^T(b-By)\le 0\)</span>, <span class="math inline">\(\alpha_r\)</span> is the extreme ray corresponding to current solution)；若SP得到最优解，且最优解的目标值大于<span class="math inline">\(z^*\)</span>，则说明存在某个极点<span class="math inline">\(\alpha_p^i\)</span>,代入目标函数得到的值大于<span class="math inline">\(z^*\)</span>，则违背了MP的约束<span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span>,因此将这个极点添加进RMP（add Benders optimality cuts:<span class="math inline">\(\alpha_p^T(b-By)\le z\)</span>, <span class="math inline">\(\alpha_p\)</span> is the extreme point corresponding to current solution),这样求解RMP得到的(b-By)与该极点向量相乘一定小于求解得到的<span class="math inline">\(z^*\)</span>；当最优解的目标值等于<span class="math inline">\(z^*\)</span>时，说明对于所有极点，与向量(b-By)的内积都小于<span class="math inline">\(z^*\)</span>，符合MP的约束，也就是说RMP得到的最优解是MP的可行解，且是MP的最优解。（松弛问题的可行域大于原问题的可行域，其最优解的目标值是原问题的下界，如果松弛问题的最优解可行，一定是原问题的最优解），这样MP也就得到了最优的解。</p><p><img src="C:/Users/64310/Desktop/GLRP/exact algorithm/benders decomposition/feasible domain.png" alt="feasible domain" style="zoom:30%;"></p><p>设求解RMP得到y的最优解在多面体极点B上，求解SP，得到最优点在极点E上，目标值为z，则对于<span class="math inline">\(\alpha\)</span>可行域任意极点<span class="math inline">\(\alpha_p^i\)</span>，<span class="math inline">\((\alpha_p^i)^T(b-By)\le z\)</span>，此时添加新的极点约束进入RMP，相当于缩小y的可行域，且缩小后的y可行域一定包含点B（因为B是符合所有极点的约束的），则<span class="math inline">\(y_{new}\)</span>的最优一定也在B，SP的最优一定还在F，对结果没有影响，可以不用添加该cut。</p><p><img src="C:/Users/64310/Desktop/GLRP/exact algorithm/benders decomposition/feasible domain1.png" alt="feasible domain1" style="zoom:30%;"></p><h2 id="伪代码">2.伪代码</h2><p><span class="math display">\[\begin{align*}&amp;\mbox{\textbf {Classic Benders Decomposition}}\\&amp;\rule{20.3cm}{0.05em}\\&amp;\mbox{Indentify the primal MP and SP}\\&amp;\mbox{repeat:}\\&amp;\quad \mbox{Solve MP, get z}\\&amp;\quad \mbox{change SP's objective funciton}\\&amp;\quad \mbox{Solve SP}\\&amp;\quad \mbox{if SP.STATUS=OPTIMAL:}\\&amp;\quad\quad \mbox{if SP.obj=z:}\\&amp;\quad\quad\quad \mbox{stop}\\&amp;\quad\quad \mbox{else:}\\&amp;\quad\quad\quad \mbox{add Benders optimality cuts:}\alpha_p^T(b-By)\le z\\&amp;\quad \mbox{else:}\\&amp;\quad\quad\quad \mbox{add Benders feasibility cuts:}\alpha_r^T(b-By)\le 0\\\end{align*}\]</span></p><h2 id="算法实例">3.算法实例</h2><p>本实例来自Wiley Encyclopedia of Operations Research and Management Science的一个章节，原PDF见<a href="http://hacivat.ie.boun.edu.tr/~taskin/pdf/taskin_benders.pdf">Benders Decompositon</a> 对MIP问题:. <span class="math display">\[\begin{align*}min\quad &amp;x_1+x_2+x_3+x_4+x_5+7y_1+7y_2+7y_3+7y_4+7y_5\\\text{s.t. }\quad &amp;x_1+x_4+x_5=8\\&amp;x_2+x_5=3\\&amp;x_3+x_4=5\\&amp;x_1\le 8y_1\\&amp;_2\le 3y_2\\&amp;x_3\le 5y_3\\&amp;x_4\le 5y_4\\&amp;x_5\le 3y_5\\&amp;x_1,x_2,x_3,x_4,x_5\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\end{align*}\]</span></p><p><strong>step1.</strong> 识别MP和SP, 记<span class="math inline">\(\overline{(b-By)}=(8,3,5,8y_1,3y_2,5y_3,5y_4,3y_5)\)</span>: <span class="math display">\[\begin{align*}\text{(RMP)=Minimize}\quad &amp;7y_1+7y_2+7y_3+7y_4+7y_5+z\\\text{s.t. }\quad &amp;z\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\\ \\ \\\text{(SP)=Maximize}\quad &amp;8\alpha_1+3\alpha_2+5\alpha_3+8y_1\alpha_4+3y_2\alpha_5+5y_3\alpha_6+5y_4\alpha_7+3y_5\alpha_8\\\text{s.t. }\quad &amp;\alpha_1+\alpha_4\le1\\&amp;\alpha_2+\alpha_5\le1\\&amp;\alpha_3+\alpha_6\le1\\&amp;\alpha_1+\alpha_3+\alpha_7\le1\\&amp;\alpha_1+\alpha_2+\alpha_8\le1\\&amp;\alpha_1,\alpha_2,\alpha_3\text{ is unrestricted, }\alpha_4,\alpha_5,\alpha_6,\alpha_7,\alpha_8\le0\end{align*}\]</span></p><p><strong>step2.</strong> 求解RMP, 得最优解为<span class="math inline">\(y^*=(0,0,0,0,0),z^*=0\)</span>, 将<span class="math inline">\(y^*\)</span>代入SP, 发现SP有无穷解, 且我们得到该解对应的极射线<span class="math inline">\((1,0,0,-1,0,0,-1,-1)\)</span>, 之后我们可以添加feasibility cut: <span class="math inline">\(8-8y_1-5y_4-3y_5\le0\)</span>,等价于<span class="math inline">\(8y_1+5y_4+3y_5\ge8\)</span></p><p><strong>step3.</strong> 更新RMP,得最优解为<span class="math inline">\(y^*=(1,0,0,0,0),z^*=0\)</span>, SP仍然无界, 对应的极射线为<span class="math inline">\((0,1,1,0,-1,-1,-1,-1)\)</span>, 继续添加feasibility cut: <span class="math inline">\(3y_2+5y_3+5y_4+3y_5\ge8\)</span></p><p><strong>step4.</strong> 更新RMP,得最优解为<span class="math inline">\(y^*=(0,0,0,1,1),z^*=0\)</span>, SP有最优解<span class="math inline">\(8&gt;z=0\)</span>, 对应的极点为<span class="math inline">\((1,0,0,0,0,0,0,0)\)</span>, 添加optimality cut: <span class="math inline">\(8\le z\)</span></p><p><strong>step5.</strong> 更新RMP, 得最优解为 <span class="math inline">\(y^*=(0,0,0,1,1),z^*=8\)</span>, 当前的<span class="math inline">\(y^*\)</span>与上一次迭代相同, 因此SP的最优值一定为8, 等于当前的<span class="math inline">\(z^*\)</span>, 算法结束. 得到SP的对偶变量, 即原问题x的取值. 且最后的RMP为: <span class="math display">\[\begin{align*}\text{(RMP)=Minimize}\quad &amp;7y_1+7y_2+7y_3+7y_4+7y_5+z\\\text{s.t. }\quad &amp;8y_1+5y_4+3y_5\ge8\\&amp;3y_2+5y_3+5y_4+3y_5\ge8\\&amp;z\ge8\\&amp;z\ge0,y_1,y_2,y_3,y_4,y_5\in \{0,1\}\end{align*}\]</span> 最终结果为<span class="math inline">\(x=(0,0,0,5,3),y=(0,0,0,1,1)\)</span>, objective=22</p><p>附Gurobi代码如下： </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gurobipy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">mp = Model()</span><br><span class="line">sp = Model()</span><br><span class="line"></span><br><span class="line">yNum = <span class="built_in">list</span>(np.arange(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">alphaNum = <span class="built_in">list</span>(np.arange(<span class="number">1</span>,<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">y = mp.addVars(yNum,obj=<span class="number">7</span>,vtype=GRB.BINARY,name=<span class="string">'y'</span>)</span><br><span class="line">z = mp.addVar(obj=<span class="number">1</span>,vtype=GRB.CONTINUOUS,name=<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">alpha = sp.addVars(alphaNum,vtype=GRB.CONTINUOUS,name=<span class="string">'alpha'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alphaNum:</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">        alpha[i].lb = -GRB.INFINITY<span class="comment">#等于约束的对偶变量无约束</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        alpha[i].lb = -GRB.INFINITY<span class="comment">#最小化问题小于约束对偶变量小于0</span></span><br><span class="line">        alpha[i].ub = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">c1 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">4</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c2 = sp.addConstr(alpha[<span class="number">2</span>]+alpha[<span class="number">5</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c3 = sp.addConstr(alpha[<span class="number">3</span>]+alpha[<span class="number">6</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c4 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">3</span>]+alpha[<span class="number">7</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">c5 = sp.addConstr(alpha[<span class="number">1</span>]+alpha[<span class="number">2</span>]+alpha[<span class="number">8</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">sp.ModelSense = GRB.MAXIMIZE</span><br><span class="line"></span><br><span class="line">sp.setParam(GRB.Param.InfUnbdInfo,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    mp.optimize()</span><br><span class="line">    sp.setObjective(<span class="number">8</span>*alpha[<span class="number">1</span>]+<span class="number">3</span>*alpha[<span class="number">2</span>]+<span class="number">5</span>*alpha[<span class="number">3</span>]+<span class="number">8</span>*y[<span class="number">1</span>].x*alpha[<span class="number">4</span>]+ \</span><br><span class="line">                    <span class="number">3</span>*y[<span class="number">2</span>].x*alpha[<span class="number">5</span>]+<span class="number">5</span>*y[<span class="number">3</span>].x*alpha[<span class="number">6</span>]+<span class="number">5</span>*y[<span class="number">4</span>].x*alpha[<span class="number">7</span>]+<span class="number">3</span>*y[<span class="number">5</span>].x*alpha[<span class="number">8</span>])</span><br><span class="line">        <span class="comment">#得到(b-By),设定subproblem的目标函数</span></span><br><span class="line">    sp.optimize()</span><br><span class="line">    <span class="keyword">if</span> sp.status == GRB.OPTIMAL:</span><br><span class="line">        <span class="keyword">if</span> sp.objVal == z.x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mp.addConstr(<span class="number">8</span>*alpha[<span class="number">1</span>].x+<span class="number">3</span>*alpha[<span class="number">2</span>].x+<span class="number">5</span>*alpha[<span class="number">3</span>].x+<span class="number">8</span>*y[<span class="number">1</span>]*alpha[<span class="number">4</span>].x+ \</span><br><span class="line">                         <span class="number">3</span>*y[<span class="number">2</span>]*alpha[<span class="number">5</span>].x+<span class="number">5</span>*y[<span class="number">3</span>]*alpha[<span class="number">6</span>].x+<span class="number">5</span>*y[<span class="number">4</span>]*alpha[<span class="number">7</span>].x+<span class="number">3</span>*y[<span class="number">5</span>]*alpha[<span class="number">8</span>].x&lt;=z)</span><br><span class="line">                <span class="comment">#add optimality cut</span></span><br><span class="line">    <span class="keyword">elif</span> sp.status == GRB.UNBOUNDED:</span><br><span class="line">        ray = sp.UnbdRay<span class="comment">#obtain extreme ray</span></span><br><span class="line">        mp.addConstr(<span class="number">8</span>*ray[<span class="number">0</span>]+<span class="number">3</span>*ray[<span class="number">1</span>] + <span class="number">5</span>*ray[<span class="number">2</span>] + \</span><br><span class="line">                     <span class="number">8</span>*ray[<span class="number">3</span>]*y[<span class="number">1</span>] + <span class="number">3</span>*ray[<span class="number">4</span>]*y[<span class="number">2</span>] + <span class="number">5</span>*ray[<span class="number">5</span>]*y[<span class="number">3</span>] + \</span><br><span class="line">                     <span class="number">5</span>*ray[<span class="number">6</span>]*y[<span class="number">4</span>] + <span class="number">3</span>*ray[<span class="number">7</span>]*y[<span class="number">5</span>]&lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#add feasibility cut</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (SP_Dual.status)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出变量值</span></span><br><span class="line">x = sp.getAttr(GRB.Attr.Pi,sp.getConstrs())<span class="comment">#x为sp对偶变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x[%d]:%g'</span>%(i+<span class="number">1</span>,x[i]))</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> mp.getVars():</span><br><span class="line">    <span class="built_in">print</span>(v.varName,<span class="string">':'</span>,v.x)</span><br></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到BraveUNow的博客</title>
      <link href="/2022/06/05/introduction/"/>
      <url>/2022/06/05/introduction/</url>
      
        <content type="html"><![CDATA[<p>这个博客是基于hexo框架的next主题制作的（<a href="https://github.com/theme-next/hexo-theme-next.git">项目地址在此</a>，欢迎各位去给大佬star），由于我对前端不是很熟悉，博客的大部分配置都是参考网上的教程，因此博客功能比较少。在博客里我主要分享一些有关运筹学或者算法编程的学习心得体会（和我以前踩过的坑<span class="github-emoji"><span>😾</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）和一些生活经历，目前博客刚刚搭建，内容还不是特别丰富，因为主要是自己写着玩没有明确的目的性，更新大概也随缘，大家见谅。（背景图片是wallpaper engine上的一个壁纸，头像是丹霞小姐姐<span class="github-emoji"><span>👀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Introduction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何角度看线性规划</title>
      <link href="/2022/06/04/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
      <url>/2022/06/04/%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>最近在阅读Dimitris Bertsimas和John N. Tsitsiklis写的Introduction to linear optimization，学习过程中发现很多基本概念及其推导在我之前学运筹学的时候都忽视了，我学习运筹学时用的教材是清华大学出版社的《运筹学》第四版，这本书虽然我觉得写得不错，但可能由于需要介绍的知识太多，很多基本概念或细节没有深入介绍，相信很多人学习这本书的感受跟我一样。因此，在学习过程中，我也希望将这些内容分享给大家。</p><p>文章的主题为从几何角度看线性规划，内容包括线性规划的一些术语（多面体、极点等）介绍和一些性质推导，阅读本章需要有一些线性代数基础（不需要很多）。由于内容有点多，可能需要分好几节来进行介绍(作者本人也在一边看一边学)，作者自己也只是一个本科生，全靠个人兴趣进行分享(可能很久才更一次<span class="github-emoji"><span>👀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>)，如果有什么地方讲得不对也希望大家能纠正。本章内容基于Introduction to linear optimization第二章，图片使用GeoGebra进行绘制。</p><span id="more"></span><h2 id="多面体和凸集">多面体和凸集</h2><h3 id="多面体">多面体</h3><p>在介绍多面体(polyhedron)之前，需要先引入超平面(hyperplane)和半空间(halfspace)的概念。假设<span class="math inline">\(a\)</span>是<span class="math inline">\(R^n\)</span>内的一个向量,<span class="math inline">\(b\)</span>是一个标量，则：</p><ul><li><strong>超平面</strong>为空间中的一个集合<span class="math inline">\(\{x\in R^n\vert a'x=b\}\)</span></li><li><strong>半空间</strong>为空间中的一个集合<span class="math inline">\(\{x\in R^n\vert a'x\ge b\}\)</span></li></ul><p>上述的意思很简单，超平面就是一条将整个空间分为两个部分的边界，在二维空间中表现为一条直线如<span class="math inline">\(x+y=1\)</span>，而半空间就是对应超平面分割空间后其中一侧的空间。注意到这里的向量<span class="math inline">\(a\)</span>其实就是对应超平面的法向量（即与超平面正交）。在了解超平面和半空间的概念后，多面体可以表示为有限数量的半空间的交集。如下图就是由<span class="math inline">\(a_i'x\ge b_i, i=1,2,3,4,5\)</span>，五个半空间的交集形成的多面体。</p><p><img src="C:/Users/64310/Pictures/线性规划/polyhedra.png" style="zoom:30%;"></p><p>因此，多面体可以表示成集合<span class="math inline">\(\{x\in R^n\vert Ax\ge B\}\)</span>，其中<span class="math inline">\(A\)</span>为<span class="math inline">\(m\times n\)</span>的矩阵，<span class="math inline">\(b\)</span>是一个<span class="math inline">\(m\times 1\)</span>的向量。特殊地，一个线性规划问题的标准形<span class="math inline">\(\{x\in R^n\vert Ax= B\}\)</span>也是一个多面体。一个多面体不一定是有界的(bounded)，如二维空间内由<span class="math inline">\((x_1\ge0,x_2\ge0)\)</span>形成的多面体就是无界的。</p><h3 id="凸集">凸集</h3><p>凸集(convex sets)的定义可以表示成：</p><ul><li>对于集合<span class="math inline">\(S\)</span>, 如果对于任何<span class="math inline">\(x,y\in S\)</span>和<span class="math inline">\(\lambda\in [0,1]\)</span>，都有<span class="math inline">\(\lambda x+(1-\lambda)y\in S\)</span>，则称集合<span class="math inline">\(S\subset R^n\)</span>是凸的(convex)。</li></ul><p><span class="math inline">\(\lambda x+(1-\lambda)y\)</span>的范围就是<span class="math inline">\(x,y\)</span>之间的一条线段，因此上述定义可以理解为，对于集合里面的任意两点之间的线段都在集合内部，则这个集合是凸集。下面引入两个概念：</p><p>设<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>为空间<span class="math inline">\(R^n\)</span>的向量，<span class="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_k\)</span>为非负标量且<span class="math inline">\(\sum_{i=1}^k\lambda_i=1\)</span></p><ul><li><p>向量<span class="math inline">\(\sum_{i=1}^k\)</span>被称为向量<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>的一个<strong>凸组合(convex combination)</strong></p></li><li><p>向量<span class="math inline">\(x^1,x^2,\dots, x^k\)</span>的<strong>凸包(convex hull)</strong>是所有这些向量的凸组合.（如下图阴影部分即是向量<span class="math inline">\(x^1,\dots,x^7\)</span>的凸包）</p></li></ul><p><img src="C:/Users/64310/Pictures/线性规划/convex_hull.png" style="zoom:50%;"></p><p>基于上面的定义，下面将介绍一些关于凸性的定理。</p><ol type="1"><li><strong>凸集之间的交集也是凸的</strong></li></ol><p><strong>证明</strong>: 设有I个凸集<span class="math inline">\(S_i, i\in I\)</span>，并假设<span class="math inline">\(x,y\)</span>属于这些凸集的交集<span class="math inline">\(\cap_{i\in I}S_i\)</span>. 由于每个<span class="math inline">\(S_i\)</span>都是凸的且都包含向量<span class="math inline">\(x,y\)</span>，则有<span class="math inline">\(\lambda x+(1-\lambda)y\in S_i\)</span>，即<span class="math inline">\(x,y\)</span>的凸组合也在所有凸集<span class="math inline">\(S_i\)</span>的交集内。因此，<span class="math inline">\(\cap_{i\in I}S_i\)</span>是凸的。</p><ol start="2" type="1"><li><strong>每个多面体都是一个凸集</strong></li></ol><p><strong>证明</strong>: 令<span class="math inline">\(a\)</span>为一个向量, <span class="math inline">\(b\)</span>为标量，假设向量<span class="math inline">\(x,y\)</span>属于同一个半空间，即<span class="math inline">\(a'x\ge b\)</span>和<span class="math inline">\(a'y\ge b\)</span>。则对任意<span class="math inline">\(\lambda\in[0,1]\)</span>，<span class="math inline">\(a'(\lambda x+(1-\lambda )y)\ge\lambda b+(1-\lambda)b=b\)</span>，表明<span class="math inline">\(\lambda x+(1-\lambda )y\)</span>也在半空间内，因此半空间是一个凸集。而前文提到了多面体是有限个半空间的交集，根据定理1，可以得到多面体一定也是凸集。</p><ol start="3" type="1"><li><strong>一个凸集内部有限个元素的凸组合也属于这个凸集</strong></li></ol><p><strong>证明</strong>: 该定理的证明可以使用数学归纳法得到。根据凸集的定义可以知道对于凸集内部任意两个元素的凸组合也在凸集内部，假设k个元素的凸组合<span class="math inline">\(\sum_{i=1}^k\lambda_ix^i\)</span>也在凸集<span class="math inline">\(S\)</span>内部，如果能证明k+1个元素<span class="math inline">\(x^1,\dots,x^{k+1}\)</span>的凸组合<span class="math inline">\(\sum_{i=1}^{k+1}\lambda_ix^i\)</span>也在凸集<span class="math inline">\(S\)</span>内部，则定理成立。这里假设<span class="math inline">\(\lambda_{k+1}\ne1\)</span>，如果等式成立则显然该凸组合就位于<span class="math inline">\(x^{k+1}\)</span>处。 <span class="math display">\[\sum_{i=1}^{k+1}\lambda_ix^i=\lambda_{k+1}x^{k+1}+(1-\lambda_{x+1})\sum_{i=1}^{k}\frac{\lambda_i}{1-\lambda_{k+1}}x^i\]</span></p><p>右侧第二项的系数<span class="math inline">\(\lambda_i/(1-\lambda_{k+1})\)</span>是非负的且和为1，即右侧括号后的部分为前k个元素的凸组合，根据假设位于凸集<span class="math inline">\(S\)</span>内部，则k+1个元素的凸组合可以转化为<span class="math inline">\(x^{k+1}\)</span>和<span class="math inline">\(\sum_{i=1}^{k}\frac{\lambda_i}{1-\lambda_{k+1}}x^i\)</span>两个元素的凸组合，根据凸集的定义，最后可以得到<span class="math inline">\(\sum_{i=1}^{k+1}\lambda_ix^i\in S\)</span>，证明完毕。</p><ol start="4" type="1"><li><strong>有限个向量的凸包也是一个凸集</strong></li></ol><p><strong>证明</strong>: 设S是向量<span class="math inline">\(x^1,\dots,x^k\)</span>的凸包，令<span class="math inline">\(y=\sum_{i=1}^k\varsigma_ix^i, z=\sum_{i=1}^k\theta_ix^i,\sum_{i=1}^k\varsigma_i=1,\sum_{i=1}^k\theta_i=1\)</span>，根据凸包定义, <span class="math inline">\(y,z\)</span>都属于<span class="math inline">\(S\)</span>，则 <span class="math display">\[\lambda y+(1-\lambda)z=\lambda\sum_{i=1}^k\varsigma_ix^i+(1-\lambda)\sum_{i=1}^k\theta_ix^i=\sum_{i=1}^k(\lambda\varsigma_i+(1-\lambda)\theta_i)x_i\]</span> 显然<span class="math inline">\(\lambda\varsigma_i+(1-\lambda)\theta_i\)</span>都是非负的且和为1，因此，<span class="math inline">\(\lambda y+(1-\lambda)z\)</span>是<span class="math inline">\(x_i\)</span>的一个凸组合，根据凸包定义一定属于<span class="math inline">\(S\)</span>。因此，可以证明凸包的凸性。</p><h2 id="极点顶点和基可行解">极点、顶点和基可行解</h2><p>大家学习单纯形法的过程中应该都了解过一个线性规划的最优解一定出现在可行域的顶点处。但什么是可行域的顶点，Bertsimas的书中给出了3中不同的定义方式，本节将一一介绍。</p><h3 id="极点extreme-point">极点(extreme point)</h3><p>多面体的极点即为无法用多面体任何其他两个元素的凸组合表示的点。它的定义如下：</p><ul><li>令<span class="math inline">\(P\)</span>为一个多面体, 向量<span class="math inline">\(x\in P\)</span>是一个极点，如果我们找不到两个向量<span class="math inline">\(y,z\in P\)</span>和标量<span class="math inline">\(\lambda\)</span>，可以使<span class="math inline">\(x=\lambda y+(1-\lambda)z\)</span></li></ul><p>用通俗的话来讲，就是如果对于多面体上的一个点不在多面体内其他任何两个点连接而成的线段上，则这个点就是多面体的一个极点。</p><p><img src="C:/Users/64310/Pictures/线性规划/extreme_point.png" style="zoom:50%;"></p><p>上图中的x是一个极点，因为<span class="math inline">\(y\notin P\)</span>，而w不是一个极点，因为它可以表示为<span class="math inline">\(v,u\)</span>的凸组合，且<span class="math inline">\(v\in P, u\in P\)</span></p><h3 id="顶点vertex">顶点（vertex)</h3><p>多面体的的顶点可以定义为关于可行域P的一些线性规划问题的唯一最优解。它的定义如下：</p><ul><li>令<span class="math inline">\(P\)</span>为一个多面体，向量<span class="math inline">\(x\in P\)</span>是P的一个顶点如果存在一些<span class="math inline">\(c\)</span>可以使<span class="math inline">\(c'x\lt c'y\)</span>，其中<span class="math inline">\(y\in P, y\ne x\)</span></li></ul><p>上述定义通俗理解就是对于点<span class="math inline">\(x\)</span>，如果存在一条经过它的一条超平面可以令<span class="math inline">\(P\)</span>中所有点都在超平面的同一侧，且只有点<span class="math inline">\(x\)</span>在超平面上，则<span class="math inline">\(x\)</span>就是多面体的一个顶点。</p><h3 id="基可行解basic-feasible-solution">基可行解(basic feasible solution)</h3><p>根据多面体的定义，一个多面体<span class="math inline">\(P\subset R^n\)</span>可以用一系列线性等式和不等式约束表示： <span class="math display">\[a_i'x\ge b_i\quad i\in M_1\\a_i'x\le b_i\quad i\in M_2\\a_i'x= b_i\quad i\in M_3\]</span> 每个<span class="math inline">\(a_i\)</span>是<span class="math inline">\(R^n\)</span>中的一个向量, <span class="math inline">\(b_i\)</span>是一个标量。如果对于向量<span class="math inline">\(x^*\)</span>，存在某些<span class="math inline">\(i\in M_1,M_2,M_3\)</span>满足<span class="math inline">\(a_i'x^*=b_i,\)</span>，则称对应的约束<span class="math inline">\(i\)</span>为在<span class="math inline">\(x^*\)</span>上的有效约束(active/binding constraints)，否则称为无效约束，显然<span class="math inline">\(M_3\)</span>中的约束都是有效约束。根据线性代数的基础知识，如果一个线性规划问题由n个有效约束，且这n个约束是线性无关(linearly independent)的，则这个问题只有唯一解。</p><p>令<span class="math inline">\(x^*\)</span>为<span class="math inline">\(R^n\)</span>中的一个点，<span class="math inline">\(I=\{i\vert a_i'x^*=b_i\}\)</span>是在<span class="math inline">\(x^*\)</span>上的有效约束的索引，则下面三种表达是等价的：</p><ol type="1"><li><p>集合<span class="math inline">\(\{a_i\vert i\in I\}\)</span>内存在n个线性无关的向量</p></li><li><p>向量<span class="math inline">\(a_i,i\in I\)</span>张成的向量空间(span)是<span class="math inline">\(R^n\)</span>，即<span class="math inline">\(R^n\)</span>内任意元素都可以表示为<span class="math inline">\(a_i\)</span>的线性组合</p></li><li><p>线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有唯一解</p></li></ol><p><strong>证明：</strong></p><p><strong>表达1和表达2</strong>：如果向量<span class="math inline">\(a_i,i\in I\)</span>的span是<span class="math inline">\(R^n\)</span>，则由线性代数的知识可得这些向量中有n个向量构成了<span class="math inline">\(R^n\)</span>的一个基，这n个向量一定是线性无关的。同样，如果集合<span class="math inline">\(\{a_i\vert i\in I\}\)</span>内存在n个线性无关的向量，则这n个向量作为基张成的向量空间一定等于<span class="math inline">\(R^n\)</span>，即<span class="math inline">\(R^n\)</span>中的任何元素都可以表示为这n个向量的线性组合。</p><p><strong>表达2和表达3</strong>：如果线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有多个解，如<span class="math inline">\(x^1,x^2\)</span>，令非零向量<span class="math inline">\(d=x^1-x^2\)</span>, 则<span class="math inline">\(a_i'd=a_i'(x^1-x^2)=0\)</span>，即<span class="math inline">\(d\)</span>与所有<span class="math inline">\(a_i\)</span>正交，因此无法用<span class="math inline">\(a_i\)</span>的线性组合表示，从而不在span(<span class="math inline">\(a_i,i\in I\)</span>)内，说明span(<span class="math inline">\(a_i,i\in I\)</span>)不包括整个<span class="math inline">\(R^n\)</span>(至少不包括<span class="math inline">\(d\)</span>)。同样，如果span(<span class="math inline">\(a_i,i\in I\)</span>)的不等于<span class="math inline">\(R^n\)</span>，存在一个非零向量<span class="math inline">\(d\)</span>与span(<span class="math inline">\(a_i,i\in I\)</span>)正交，如果存在<span class="math inline">\(x\)</span>满足<span class="math inline">\(a_i'x=b_i,i\in I\)</span>，则<span class="math inline">\(a_i'(x+d)=b_i,i\in I\)</span>也一定满足，因此该线性方程组有多个解。</p><p>因此，如果对于一个有n个变量的线性规划问题，如果我们能找到n个有效约束则能唯一确定一个解。因此，这里引出了基解(basic solution)和基可行解的概念(basic feasible solution)。对于一个由一系列等式约束和不等式约束定义的多面体<span class="math inline">\(P\)</span>, 令<span class="math inline">\(x^*\)</span>为<span class="math inline">\(R^n\)</span>中的一个向量。</p><ul><li>所有在<span class="math inline">\(x^*\)</span>的有效约束中有<span class="math inline">\(n\)</span>个约束是线性无关的，则求解线性方程组得到的<span class="math inline">\(x^*\)</span>是一个<strong>基解</strong>.</li><li>如果<span class="math inline">\(x^*\)</span>是一个基解，且满足所有的约束，则是一个基可行解。</li></ul><p>对于一个线性规划问题，假设有n个变量，m个约束，其中有k个线性无关的等式约束，我们可以中所有不等式约束中寻找(n-k)个约束令其满足等式约束，这样就可以得到n个有效约束。</p><p><img src="C:/Users/64310/Pictures/线性规划/basic_solution.png" style="zoom:15%;"></p><p>假设线性规划问题的约束包括<span class="math inline">\(c_1:x+y\le 2;c_2:x-y\ge-1;c_3:x\ge0;c_4:y\ge0\)</span>，可行域如上图阴影部分区域所示，显然图中所有点都是都是基解，因为他们至少满足了两条线性无关的有效约束，如点E存在有效约束<span class="math inline">\(c_2,c_4\)</span>。但只有C、D、E、F是基可行解。</p><h3 id="extreme-point-vertex-basic-feasible-solution">extreme point, vertex, basic feasible solution</h3><p>以上三种概念虽然表达方式不同，但其实是等价的，并可以互换使用。本节将进行等价性的证明。</p><p><strong>vertex<span class="math inline">\(\rightarrow\)</span>extreme point</strong>：设<span class="math inline">\(x^*\in P\)</span>是一个顶点，则存在向量<span class="math inline">\(c\)</span>满足<span class="math inline">\(c'x^*\lt c'y,y\in P,y\ne x^*\)</span>。设有<span class="math inline">\(y\in P,y\ne x^*,z\in P,z\ne x^*\)</span>，则<span class="math inline">\(c'y\gt c'x^*,c'z\gt c'x^*\)</span>，<span class="math inline">\(c'(\lambda y+(1-\lambda)z)\gt c'x^*\)</span>，所以<span class="math inline">\((\lambda y+(1-\lambda)z)\ne x^*\)</span>因此<span class="math inline">\(x^*\)</span>无法表示为P中任意两个元素的凸组合, 是一个极点。</p><p><strong>extreme point<span class="math inline">\(\rightarrow\)</span> basic feasible solution</strong>：只要证明如果<span class="math inline">\(x^*\in P\)</span>不是一个基可行解，那一定不是极点即可。不是基可行解有两种情况。令<span class="math inline">\(I=\{a_i\vert a_ix^*=b_i\}\)</span>表示有效约束的集合，如果不存在n个线性无关的约束，则span(<span class="math inline">\(a_i,i\in I\)</span>)是<span class="math inline">\(R^n\)</span>的一个子集，一定存在<span class="math inline">\(d\in R^n\)</span>正交于所有约束向量令<span class="math inline">\(a_id=0,i\in I\)</span>。令<span class="math inline">\(\epsilon\)</span>是 一个很小的正数，并令<span class="math inline">\(y=x^*+\epsilon d,z=x^*-\epsilon d\)</span>，则对于所有有效约束<span class="math inline">\(i\in I\)</span>有<span class="math inline">\(a_i'y=a_i'z=0\)</span>，而对于无效约束<span class="math inline">\(i\notin I\)</span>，由于<span class="math inline">\(a_i'x^*\gt b_i\)</span>，由于<span class="math inline">\(\epsilon\)</span>很小(<span class="math inline">\(\epsilon\vert a_i'd\vert\lt a_i'x^*-b_i\)</span>)，则<span class="math inline">\(a_i'y\gt b_i,a_i'z\gt b_i\)</span>，因此<span class="math inline">\(y,z\)</span>都满足所有约束，使<span class="math inline">\(y\in P, z\in P\)</span>，则<span class="math inline">\(x^*=(y+z)/2\)</span>，可以表示为两个向量的凸组合；另一种情况是存在n个线性无关的有效约束，但<span class="math inline">\(x^*\)</span>违背了部分无效约束，即<span class="math inline">\(x^*\)</span>为basic solution, 不是basic feasible solution，则<span class="math inline">\(x^*\notin P\)</span>，自然不是极点了。</p><p><strong>basic feasible solution<span class="math inline">\(\rightarrow\)</span> vertex</strong>：如上令<span class="math inline">\(x^*\)</span>为一个basic feasible solution，<span class="math inline">\(I=\{a_i\vert a_ix^*=b_i\}\)</span>表示有效约束的集合，令<span class="math inline">\(c=\sum_{i\in I}a_i\)</span>,则有: <span class="math display">\[c'x^*=\sum_{i\in I}a_i'x^*=\sum_{i\in I}b^i\]</span> 此外，对于任何<span class="math inline">\(x\in P\)</span>，都满足所有约束<span class="math inline">\(a_i'x\ge b_i\)</span>，则 <span class="math display">\[c'x=\sum_{i\in I}a_i'x\ge \sum_{i\in I}b_i\]</span> 将<span class="math inline">\(c'x\)</span>当作一个目标函数，则<span class="math inline">\(x^*\)</span>是这个问题的下界，由于<span class="math inline">\(x^*\)</span>是一个基可行解，因此在<span class="math inline">\(x^*\)</span>处存在n个线性无关的有效约束，根据前面的证明这是与由这n个有效约束组成的线性方程组<span class="math inline">\(a_i'x=b_i,i\in I\)</span>有唯一解是等价的，因此<span class="math inline">\(c'x\)</span>只有在 <span class="math inline">\(x^*\)</span>才能使等式成立，对于所有<span class="math inline">\(x\in P,x\ne x^*\)</span>，都有<span class="math inline">\(c'x\gt c'x^*\)</span>，因此<span class="math inline">\(x^*\)</span>是一个vertex。</p><p>因此，如果一个向量是多面体的extreme point, 那它一定也是多面体的vertex或线性规划问题的一个basic feasible solution.</p><p>如果给定有限数量的线性不等式约束，则只有有限个数量的basic solution或basic feasible solution，也就是说一个多面体的extreme point或vertex的数量是有限的（但这个数字可能会很大）。</p><p><strong>证明</strong>：假设线性规划问题有m个不等式约束，由于任何basic solution都可以由n个线性无关的约束组成的线性方程组唯一确定，因此只需要在m个约束中找到n个线性无关的约束令等式成立就能获得一个basic solution，则basic solution的数量实际上是受限于m个不等式约束中能找到的n个线性无关约束的数量。</p><p>本章的内容先写到这里（肝了大半天写不动了<span class="github-emoji"><span>😫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），写着写着发现自己好像基本就是在翻译书本<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（但有些部分还是加了点个人理解，虽然不一定正确，作为本科生懂得真的不多），如果大家对此感兴趣还是欢迎大家去阅读原书。由于最近有好多事要做，之后的更新就随缘了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
